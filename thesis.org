#+TITLE: RTIC Scope — Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [twocolumn]
#+options: toc:nil
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[citestyle=authoryear-icomp,bibstyle=authoryear, hyperref=true,maxcitenames=3,url=true,backend=biber,natbib=true]{biblatex}
#+latex_header: \addbibresource{ref.bib}
#+latex_header: \usepackage{microtype}

\begin{abstract}
TODO
\end{abstract}

* TODO Introduction
** TODO Background
   RTIC (cite:rtic) is a real-time operating system (RTOS) based on the
   stack resource policy (cite:baker90) for task scheduling written in
   the Rust programming language. RTIC supports the ARM Cortex-M4 family
   of microprocessor core units (MCUs) which, in turn, offer
   asynchronous debug facilites for real-time tracing support
   (cite:arm-rm, §C). Of chief interest are
   - DWT, :: Data Watchpoint and Trace (cite:arm-rm, §C1.8): contains
     program counter and address comparators that signal on a match; and
   - ITM, :: Intrumentation Trace Macrocell (cite:arm-rm, §C1.7): trace
     information generator in the form of packets; multiplexes trace
     information from other sources (e.g. DWT).

   # Ref. does not say that ITM is real-time.
   Tracing is the ability to analyse the behavior of an embedded system
   in real-time without significantly affecting the user application,
   known as non-intrusive debugging. Proper application of tracing
   allows the developer to verify the behavior of an embedded system.

   ITM is realized in practise by communicating between the embedded
   system and the analysing system with a packet protocol. (cite:arm-rm,
   Appendix D4)

   # This does not fit in the background
   If the embedded system has the capability, tracing data may be buffered
   locally before it is transferred to an external system. The information
   can also be captured by monitoring a serial pin.

** TODO Motivation
   Debugging an user application running on an MCU is an integral part of
   an embedded work-flow. Thus, the more debugging facilities that are
   readily available to the end-user of an RTOS, the better. More so if
   proper usage of such facilities — which, in the case of the non-trivial
   nature of ITM — is abstracted. However, care must be taken when designing
   debugging features on an embedded target as it must not affect the user
   application, lest real-time properties will differ between a debug and
   production build, in which tracing may be disabled.

   # Talk about RTIC and its increasing usage
   # We want to make it very simple for the end user to trace an application

** TODO Problem definition
   # We want to be able to just write trace = true in the RTIC
   # application

   This project is divided into three sub-projects (ordered by
   decreasing complexity):
   - A tracing feature abstraction for arbitrary RTIC tasks: :: it
     should be trivial for the end-user to enable tracing of a set of
     tasks in the user application. This will trace four types of
     timestamped events related to these tasks, namely when a task
     - starts executing;
     - stops executing; and
     - sends a message.
   - A host-side trace-recoring daemon: :: when a user application is
     being traced, a daemon will be responsible for the capture,
     eventual reordering of, and flushing of these ITM packages to a
     host-local file for later or real-time analysis by another utility.
   - A utility for packet decoding: :: a simple CLI[fn:cli] program that
     decodes the recorded packets to a human-readable format.

   If time is available, practical examples of this tracing feature will
   be made to display its real-world applications. If time is not
   available, these applications will instead be argued for.

** TODO Limitations
   # Will we touch ETM?

** TODO Thesis structure

* Related work
  The aim of this project is thus to investigate if non-intrusive
  tracing can be sufficiently abstracted and be readily made available
  for the RTIC end-user.

  Some work has already been made to integrate ITM tracing in an RTIC
  application[fn:itm-tools], but the approach is ad-hoc and not
  abstracted for the user. Nevertheless, a base to work from is
  available and will be used. Further, probe-rs is an extensible
  debugging toolkit with in-development support for ITM tracing
  (cite:probe-rs) that fits into the ecosystem of RTIC. Work will be
  done on this toolkit to enable a "batteries included" implementation
  of the problem solution.

  If it is found that more data than what ITM can provide is required
  for further tracing details, the usage of RTT will be
  investigated. [fn:memory-lanes]

  # (Probably) refer to other (proprietary) implementations

* Theory
** Hardware tasks
   Hardware tasks are regular Rust functions that are bound to a
   hardware interrupt. When this interrupt is made pending in hardware,
   the task function executes. An example hardware task is declared via
   #+name: rtic-hw-task-example
   #+begin_src rust
     #[app]
     mod app {
         #[task(bound = EXTI0)]
         fn foo(_ctx: foo::Context) {
             // ...
         }
     }
   #+end_src
   With this declaration, =foo= will be executed when ~EXTI0~ is made
   pending in hardware. After =foo= returns, the interrupt has been
   handled and ~EXTI0~ is no longer pending.

*** Tracing behavior
    Hardware tasks are exclusively bound to singular hardware interrupts.
    Because of this, whenever an interrupt handler executes (and thus the
    bound hardware task), an =ExceptionTrace { exception, function }=
    packet is emitted, where =exception= is the exception number as an
    integer and =function= is the action context of the exception: an
    exception is either entered, exited, or returned.
** DWT
# TODO Expain what it is and how it works.

** Software tasks
   Software tasks are also regular Rust functions that are bound to
   hardware interrupts, but the bound hardware interrupt is not
   exclusively associated to the task in question: a single hardware
   interrupt can be associated with multiple software tasks. For this
   reason, the used hardware interrupt is considered a "dispatcher".

   An example software task is declared via
   #+begin_src rust
     #[app(dispatchers = [EXTI0])]
     mod app {
         #[task]
         fn bar(_ctx: bar::Context) {
             // ...
         }
     }
   #+end_src

   In difference to hardware tasks, software tasks can be scheduled by
   software.

*** Tracing behavior
    Because the implementation of software tasks utilizes hardware
    interrupts, software tasks can be traced in the same manner as
    hardware tasks if it is ensured that every dispatcher only manages a
    single software task. However, in practise a dispatcher commonly
    manager multiple software tasks. An emitted =ExceptionTrace= thus
    tells us when a dispatcher starts, but not which software task it
    dispatches.

*** RTIC task name resolving
    The =ExceptionTrace= does not give us all the information we need.
    Instead, a [[DWT]] unit can be employed to emit =DataTraceValue= packets
    on software task enter and exit. Via this approach, each software
    task is given a unique ID and code is injected (either by the
    =rtic::app= macro or by the end-user themselves) to write this
    unique ID at the start and end of the software task. The emitted
    =DataTraceValue= packets are then analysed by the host application,
    which maintains a state of which software task is currenly
    running. [fn:dwt-running-bit] The RTIC application source is then
    parsed to associate =DataTraceValue= payloads back to their software
    tasks.

    In comparison to hardware tasks, which are practically traced for
    free, software tasks can be traced at the cost of a few register
    writes and a dedicated DWT unit.
* Implementation

* Evaluation

* Discussion

\printbibliography

* Footnotes

[fn:dwt-running-bit] Alternatively, one bit in the =DataTraceValue=
payload can denote whether a task was entered or exited.

[fn:decoder] Based upon the existing works of ~itm-tools~[fn:itm-tools].

[fn:memory-lanes] https://github.com/rtic-rs/rfcs/issues/31 discusses
the RTIC-abstraction of RTT and similar peripherals to "memory lanes".

[fn:itm-tools] See https://github.com/japaric/itm-tools.

[fn:cli] Command-line interface.
