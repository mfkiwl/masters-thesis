# -*- eval: (org-indent-mode +1) -*-
# -*- eval: (visual-line-mode +1) -*-

#+TITLE: RTIC Scope â€” Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Vilhelm Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LANGUAGE: en
#+OPTIONS: ':t toc:nil title:nil todo:nil H:6

#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: thesis
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+latex_header: \usepackage{kpfonts}[maths]
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[style=apa,hyperref=true,url=true,backend=biber]{biblatex}
#+latex_header: \addbibresource{./ref.bib}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{frame=lines,breaklines,breakafter=/.,fontsize=\footnotesize,linenos}
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor={red!50!black},citecolor=blue,breaklinks=true}
#+LATEX_HEADER: \usepackage{glossaries}
#+latex_header: \usepackage{microtype}
#+latex_header: \usepackage{tocbibind}
#+latex_header: \usepackage{todonotes}
#+latex_header: \usepackage[capitalize]{cleveref}
#+LATEX_HEADER: \makeglossaries

# NOTE auto linebreaks / : - and _ inside \textttBreak. Adapted from <https://tex.stackexchange.com/a/219497>.
#+latex_header: \catcode`_=12 %
#+latex_header: \newcommand{\textttBreak}[1]{%
#+latex_header:   \begingroup
#+latex_header:   \ttfamily
#+latex_header:   \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`-\lowercase{\endgroup\def~}{-\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`_\lowercase{\endgroup\def~}{_\discretionary{}{}{}}%
#+latex_header:   \begingroup\lccode`~=`:\lowercase{\endgroup\def~}{:\discretionary{}{}{}}%
#+latex_header:   \catcode`/=\active\catcode`-=\active\catcode`_=\active\catcode`:=\active
#+latex_header:   \scantokens{#1\noexpand}%
#+latex_header:   \endgroup
#+latex_header: }
#+latex_header: \catcode`_=8 %

#+latex_header: \usepackage[htt]{hyphenat}

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

#+NAME: glossary
| label       | name            | description |
|-------------+-----------------+-------------|
| tokenstream | tokenstream     | cock        |
| token       | token           | TODO        |
| static-anal | static analysis | TODO        |
| sample-rate | sample rate     | TODO        |
| downstream  | downstream      | TODO        |
| frontend    | frontend        | TODO        |
| upstream    | upstream        | TODO        |
| elf:data    | \texttt{.data}  | TODO        |
| JSON        | JSON            | TODO        |
| cdylib      | cdylib          | TODO        |

# TODO cdylib above: A cdylib crate is a crate that specifies =crate_type = ["cdylib"]=. Upon building the crate a dynamic library (a shared object file) that targets the stable C ABI is generated. Additionally, it is trivial to find the file location of cdylibs with cargo. This is not the case with dylibs that instead target the unstable Rust ABI. The only way to generate a shared object file is by building a dylib or a cdylib.

# XXX some of these should link to the glossary
#+NAME: acronyms
| key           | abbreviation     | full form                                             |
|---------------+------------------+-------------------------------------------------------|
| PC            | PC               | \textit{program counter}                              |
| CPU           | CPU              | \textit{central processing unit}                      |
| RTIC          | RTIC             | \textit{Real-Time Interrupt-driven Concurrency}       |
| RTOS          | RTOS             | \textit{real-time operating system}                   |
| SRP           | SRP              | \textit{Stack Resource Policy}                        |
| DCB           | DCB              | \textit{Debug Control Block}                          |
| SCS           | SCS              | \textit{System Control Space}                         |
| SCB           | SCB              | \textit{System Control Block}                         |
| DCB_DEMCR     | DEMCR            | \textit{Debug Exception and Monitor Control Register} |
| ITM           | ITM              | \textit{Instrumentation Trace Macrocell}              |
| TPIU          | TPIU             | \textit{Trace Port Interface Unit}                    |
| DWT           | DWT              | \textit{Data Watchpoint and Trace}                    |
| ETB           | ETB              | \textit{Embedded Trace Buffer}                        |
| WCET          | WCET             | \textit{Worst Case Execution Time}                    |
| EDF           | EDF              | \textit{Earliest Deadline First}                      |
| PAC           | PAC              | \textit{Peripheral Access Crates}                     |
| API           | API              | \textit{Application Programming Interface}            |
| TPIU_ACPR     | TPIU\_ACPR       | \textit{Asynchronous Clock Prescaler Register}        |
| ETM           | ETM              | \textit{Embedded Trace Macrocell}                     |
| DWT_CTRL      | DWT\_CTRL        | \textit{Control Register}                             |
| TPIU_TYPE     | TPIU\_TYPE       | \textit{TPIU Type Register}                           |
| ITM_TCR       | TPIU\_TCR        | \textit{Trace Control Register}                       |
| RAZ-WI        | RAZ/WI           | \textit{Read-As-Zero, Writes Ignored}                 |
| RAZ           | RAZ              | \textit{Read-As-Zero}                                 |
| RAO           | RAO              | \textit{Read-As-One}                                  |
| DWT_FUNCTIONn | DWT\_FUNCTION$n$ | \textit{Comparator Function registers}                |
| SBZ           | SBZ              | \textit{Should-Be-Zero}                               |
| DWT_COMPn     | DWT\_COMP$n$     | \textit{Comparator registers}                         |
| DWT_MASKn     | DWT\_MASK$n$     | \textit{Comparator Mask registers}                    |
| AST           | AST              | \textit{Abstract Syntax Tree}                         |
| TLV           | TLV              | \textit{type-length-value}                            |
| GTS1          | GTS1             | \textit{Global timestamp packet format 1}             |
| GTS2          | GTS2             | \textit{Global timestamp packet format 2}             |
| LTS1          | LTS1             | \textit{Local timestamp packet format 1}              |
| LTS2          | LTS2             | \textit{Local timestamp packet format 2}              |
| IPSR          | IPSR             | \textit{Interrupt Program Status Register}            |

# TODO install and apply a grammar checker.
# TODO use glossary everywhere <https://www.overleaf.com/learn/latex/Glossaries>
# TODO +NAME all listings?
# TODO cite any mentioned crates.
# TODO call an RTIC app just that, or firmware, throughout.
# TODO fix cites to sections (remove the "p."?)
# TODO verify software versions with Cargo.lock from v0.3.0 tag.
# TODO fix hbox overflows on texttt in list of listings, bibliography, glossary
# TODO fix second list of listings page saying "list of figures"
# TODO tweak geometry for last overfull hboxes
# TODO replace ~~ with == in regular text
# TODO fix memoir page header to use H:3
# TODO ask ARM about permission to copy figures/tables?
# TODO copy more relevant images from ARM spec.

* Org setup                                                        :noexport:
  #+begin_src emacs-lisp :result output :session :exports both
    ;; ignore some headlines
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))

    ;; minted code listings
    (require 'ox-latex)
    (setq org-latex-listings 'minted)

    ;; use the book class, but without any \parts
    (add-to-list 'org-latex-classes
                 '("thesis"
                   "\\documentclass{memoir}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    ;; use \cref instead of \ref, for cleveref
    (setq org-ref-default-ref-type "cref")
    (setq org-latex-prefer-user-labels t)

    ;; setup org-ref
    (setq bibtex-completion-bibliography '("./ref.bib")
          org-export-before-parsing-hook '(org-ref-glossary-before-parsing
                                           org-ref-acronyms-before-parsing))

    ;; make so that =some text= yield \textttBreak{some text} instead of
    ;; \texttt{some text}.
    ;;
    ;; NOTE do not use =some text= in section headings or captions.
    (defun org-latex--protect-texttt (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\texttt{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&_#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--protect-textttbreak (text)
      "Protect special chars, then wrap TEXT in \"\\texttt{}\"."
      (format "\\textttBreak{%s}"
              (replace-regexp-in-string
               "--\\|[\\{}$%&#~^]"
               (lambda (m)
                 (cond ((equal m "--") "-{}-")
                       ((equal m "\\") "\\textbackslash{}")
                       ((equal m "~") "\\textasciitilde{}")
                       ((equal m "^") "\\textasciicircum{}")
                       (t (org-latex--protect-text m))))
               text nil t)))
    (defun org-latex--text-markup (text markup info)
      "Format TEXT depending on MARKUP text markup.
       INFO is a plist used as a communication channel.  See
       `org-latex-text-markup-alist' for details."
      (let ((fmt (cdr (assq markup (plist-get info :latex-text-markup-alist)))))
        (cl-case fmt
          ;; No format string: Return raw text.
          ((nil) text)
          ;; Handle the `verb' special case: Find an appropriate separator
          ;; and use "\\verb" command.
          (verb
           (let ((separator (org-latex--find-verb-separator text)))
             (concat "\\verb"
                     separator
                     (replace-regexp-in-string "\n" " " text)
                     separator)))
          (protectedtexttt (org-latex--protect-texttt text))
          (protectedtextttbreak (org-latex--protect-textttbreak text))
          ;; Else use format string.
          (t (format fmt text)))))
    (setq org-latex-text-markup-alist
          '((bold . "\\textbf{%s}")
            (code . protectedtexttt)
            (italic . "\\emph{%s}")
            (strike-through . "\\sout{%s}")
            (underline . "\\uline{%s}")
            (verbatim . protectedtextttbreak)))
  #+end_src
#+RESULTS:

* Frontmatter                                                        :ignore:
#+LATEX: \frontmatter
# Make this a single paragraph; use unambiguous terms; aim for 250 words; 3-5 keywords.
#+begin_abstract
Here be an abstract...
#+end_abstract
#+begin_export latex
\newlist{inline-enum}{enumerate*}{1}
\setlist[inline-enum]{label=(\roman*)}

% Include "List of Listings" in the TOC
\renewcommand{\listoflistings}{
  \cleardoublepage
  \addcontentsline{toc}{chapter}{\listoflistingscaption}
  \listof{listing}{\listoflistingscaption}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\listoftodos
\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage
\listoflistings
\newpage

% Start counting with arabic numbers
\mainmatter

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Fix todonotes behavior
\setlength{\marginparwidth}{2cm}
\reversemarginpar
#+end_export

* *The Paper*                                                        :ignore:
** Introduction
# What are embedded systems, regulators, and how do they relate?
Embedded systems --- a unit combination of a central processing unit, system memory, and input/output peripheral devices --- serve a key role in the operation of systems with electronical components where computations must be made.
A prime examples of such systems are digital control systems which regulate one or more control quantities such that they adhere to designed characteristics.
Often the goal is to track a reference signal; such a control system is known as a regulator.
A regulator observes (either directly or by approximation) the internal states of a system under control via sensors and affect the system via actuators.
For example, one may wish to keep a rocket on a set path to reach orbit, or control the internals of a nuclear power plant to maximize electrical power output while keeping the plant within safe operation boundaries.

# On the real-time restrictions of control systems; exponential complexity phenomena.
A key design parameter of digital controllers is the [[gls:sample-rate][sample rate]]: if too low or unconsistent, the controlled system will end up unstable [[parencite:&franklin]].
The rocket may thus fly off course, or the nuclear reactor reach a meltdown.
This puts a real-time constrain on the digital controller which greatly limits how it can be implemented.
Further, a digital controller under implementation must be debugged so that the engineers can verify its correct operation and realize the real-time constrain.
This task grows exponentially in difficulty with as the number of system states, inputs, and outputs increase.
A similar phenomena is observed for embedded systems with an increasing number of tasks.[fn:2]

# The observer effect; data exfiltration.
Unfortunately are embedded systems subject to the observer effect: to observe the internal state of a embedded system (i.e., system variables in memory) its operation must be affected.
# A proper implementation would not block on a serial write.
This observeration is often realized by exfiltrating data via serial communication which in the best case can induce bus contention and full output queues,
but it is not uncommon that a program blocks until the data has been serialized, severely affecting the regulation if the payload is large.
In a perfect implementation, the user application[fn:1] would only concern itself with its mainsake regulation procedure and leave data exfiltration to a completely disjoint system, removing the observer effect and thus the effect on the underlying control system.

# ARM, tracing subsystem and possible exploitation.
ARM is an ubiquitous vendor for embedded systems with a number of sub-vendors (e.g. STMicroelectrics, NXP Semiconductors, Nordic Semiconductors).
The ARMv7-M platform standard offers debugging facilities that enables the developer to trace the system.
From [[textcite:&arm-cortex-learn]]: "Trace refers to the process of capturing data that illustrates how the components in a design are operating, executing, and performing".
Additionally, "[Trace generation is] almost entirely non-invasive. [Trace generation] does not influence the wider system".
These trace facilities allows for an event-based monitoring of
- interrupt handler enters and exits (tracing of hardware-bound tasks);
- Read and write access to in-memory address spaces (system state variables, software tasks); and
- [[acrfull:PC]] samples, among other features.
The generated trace is then exfiltrated via asynchronous serial using a packet protocol (described in [[#debug-periphs]]), henceforth referred to as the "trace stream".
These facilities are not disjoint (if they were, no insight into the system could be offered) but because the generation of the trace stream does not influence the wider system (as per [[citeauthor:&arm-cortex-learn]]) the trace stream (with system-external collection) is a suitable candidate for exploitation to realize insight into a control system with minimal observer effect.

# Less work, more sleep.
Further, with non-invasive trace generation, less code must be executed by the [[acrfull:CPU]], allowing a shorter duty-cycle of the user application.
With a decreased duty-cycle, the system can be put to sleep longer, and thus conserve energy.

# On real-time implementation restictions, embedded implementation difficulties in general. Enter RTIC.
The development of embedded system in general is a difficult one.
In comparison to general-purpose computers, where one often need not worry about resource limitations, embedded systems are constrained in all manners such that costs can be minimized for their non-general applications.
# No rich OS; no two embedded platforms are the same.
An embedded developer seldom have access to a rich operating systems --- a Linux-based distibution, for example --- which offers general-purpose facilities based on dynamic allocations and a common environment to simplify implementation.
Embedded platforms usually differ significantly, and porting an implementation to another platform is no small task.
This compares to general-purpose computers where a program written on one computer can be executed on another one, as long as the operating environment remains the same.
# Side effects and priority inversions.
Embedded platforms are much more subject to side-effects where peripherals are operated by writing data to memory-mapped registers.
Of certain importance is the problem of priority inversions, where a task of lower priority executes instead of a higher prioritized task because of implementation error.
In summary it is easy to put an embedded system in an incorrect or unknown state.
# Enter RTIC.
In order to lighten the implementation burden one may employ [[Acrfull:RTIC]] (see [[#rtic]]), [[textcite:&rtic]]: a [[Acrfull:RTOS]] developed at LuleÃ¥ Technical University based on the extensively studied [[Acrfull:SRP]], which
- prevents deadlocks;
- mitigates priority inversions; and
- is compatible with [[Acrfull:EDF]] sheduling [[parencite:&srp]].
RTIC thus removes some burden out-of-the-box while also
- implementing message passing between tasks;
- incurring a minimal scheduling overhead;
- being highly efficient on memory usage; and
- being amenable to [[Acrfull:WCET]] analysis [[parencite:&rauk]].

# Oh yeah, and Rust
RTIC is written in Rust which removes additional developer overhead (see [[#rust]]).

# Project aim
The aim of this thesis is thus to employ and extend upon RTIC with a toolset, aptly named RTIC Scope, to leverage [[Citeauthor:&arm-cortex-learn][ARM]]'s non-intrusive tracing facilites while requiring minimal overhead for the end-user developer to apply the toolset, greatly lightening the burden when implementing a digital control systems.
The resulting toolset will be employed to implement a regulator for a non-trivial dynamic system (see [[#control-application]]), and the functionality and ergonomics of the toolset evaluated (see [[#discussion]]).

*** Background
This introductory section covers the software components that have realized RTIC Scope.

**** The Rust programming language
:PROPERTIES:
:CUSTOM_ID: rust
:END:
Rust is a system programming language that guarantees the absence of mutable aliasing and defined run-time behavior as long as code is written in a /safe/ context.
Refer to [[textcite:&rust-lang]].

For a summary of Rust in an embedded context, refer to [[textcite:&tjader2021rtic 6--8]].

**** [[Acrfull:PAC]]
:PROPERTIES:
:CUSTOM_ID: background:PAC
:END:
# What is a PAC and what are they used for?
A PAC is a Rust library crate which exposes an [[gls:API]] for hardware peripherals.
Rather than providing an ad-hoc implementation inlined in an embedded application, a PAC provides a convenient interface to read and write to memory-mapped registers in order to mutate (in order to configure) and query (in order to poll the status of) hardware peripherals.

# Differentiate {architecture,device}-specific PACs
In the embedded Rust ecosystems, these are two kinds of PACs:
- architecture-specific :: Architecture-specific PACs expose an API for hardware peripherals common to all embedded systems that share the same architecture, commonly denoted as a "family". For example, ~cortex-m~ [[parencite:&cortex-m]] is a PAC that targets the ARM Cortex-M family of embedded systems, which is based on the ARMv7-M standard.
- device-specific :: Device-specific PACs expose an API for hardware peripherals available on a smaller family of embedded systems.
  For example, ~stm32-rs~ [[parencite:&stm32-pac]] is a collection of PACs targeting all microcontrollers in the STMicroelectronics STM32 family.

# svd2rust
A common tool to generate PACs is ~svd2rust~ [[parencite:&svd2rust]].

# TODO reformat
An example declaration of such an enum can be seen in [[lst:pac-interrupt-example]].
#+NAME: lst:pac-interrupt-example
#+CAPTION: Example declaration of a ~PAC::Interrupt~ enum. Left-hand side of ~Interrupt~ is the IRQ label; right-hand is $N$ in [[tbl:irqns]].
#+begin_src rust
  pub mod PAC {
      #[derive(Debug)]
      #[repr(u16)]
      pub enum Interrupt {
          PVD = 1,
          EXTI0 = 6,
          EXTI1 = 7,
          // ...
      }

      unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
          #[inline(always)]
          fn number(self) -> u16 {
              self as u16
          }
      }
  }
#+end_src

**** [[Acrfull:RTIC]]
:PROPERTIES:
:CUSTOM_ID: rtic
:END:

# TODO Expand: briefly cover rtic::app, how an application is declared, hardware tasks (PAC usage) and task dispatchers.
Hardware tasks are regular Rust functions that are bound to a hardware interrupt.
When this interrupt is made pending in hardware, the task function executes.
An example hardware task is declared via
#+name: rtic-hw-task-example
#+begin_src rust
  #[rtic::app]
  mod app {
      #[task(bound = EXTI0)]
      fn foo(_ctx: foo::Context) {
          // ...
      }
  }
#+end_src
With this declaration, =foo= will be executed when ~EXTI0~ is made pending in hardware.
After =foo= returns, the interrupt has been handled and ~EXTI0~ is no longer pending.


Software tasks are also regular Rust functions that are bound to hardware interrupts, but the bound hardware interrupt is not exclusively associated to the task in question: a single hardware interrupt can be associated with multiple software tasks.
For this reason, the used hardware interrupt is considered a "dispatcher".
An example software task is declared via
#+begin_src rust
  #[rtic::app(dispatchers = [EXTI0])]
  mod app {
      #[task]
      fn bar(_ctx: bar::Context) {
          // ...
      }
  }
#+end_src

In difference to hardware tasks, software tasks can be scheduled by software.
**** Hardware debuggers (probes)
# TODO required for a host system to flash and read data from an embedded system

*** Motivation
# We must cross a hardware boundry when debugging embedded systems.
Debugging the code being executed in an embedded system is an integral part of an embedded work-flow similar to how it is common to attach to and debug a process of a program being developed on a general-purpose computer.
The latter process can be considered trivial because no hardware boundries must be crossed; the debugger and debugged program are (usually) contained within the same system.
Debugging an embedded system is on the other hand non-trivial: the embedded system is its own contained system and a line of communication[fn:: Which requires a hardware debugger.] must be established with a host system to debug the embedded system.
\missingfigure{Draw a comparison between conventional debugging and embedded debugging.}

# We want to be able to debug in real-time (read: trace), but also record it.
An important aspect of debugging is the act of debugging in real-time, often referred to as the act of "tracing".
By tracing an embedded system it is possible to verify its internal operations continuously as long as a debugger is attached.
Another important aspect of debugging are post-mortem analyses: being able to analyse a system's run-time behavior before it ended up in an invalid or unexpected state after the fact.
Port-mortem analyses are realized by recording a trace from the attached debugger.
Such analyses are useful for systems deployed "in the field" which are seldom continuously controlled by human hands.
An example of such a system is a charger for electrical vehicles: verifying the operation of the charger is much easier before it is permanently installed at a parking space and expected to operate continuously.
If the charger breaks the responsible engineers will want to have a detailed log of events that occured before the device broke in order to improve it.

# Tracing is zero-cost by help of hardware, but not trivial to configure.
Tracing is supported by hardware debug facilities on the ARMv7-M platform, as is the exfiltration of the trace stream from the device (a line of communication which can be read by a host system).
Enabling and correctly configuring these facilites to generate a trace stream and decoding the trace stream itself is no trivial task, however.

# The emergence of RTIC, and its lack of debug tools.
RTIC is a novel RTOS which offers improvements over conventional RTOSs [[parencite:&tjader2021rtic 23]].
The motivation behind RTIC Scope is thus to offer a "batteries included"[fn:: where details regarding trace stream generation and decoding is abstracted, and where no additional work must be done to utilize the tool.] toolset that enables instant insight into an RTIC application.
Such a toolset would make it easier to verify the implementation of an RTIC application.

# Control application.
RTIC Scope will then be used to verify the implementation of a regulator for a complex dynamic system (see [[#control-application]]).
This is done in order to establish a base-line for the end-user experience of the toolset, in order to improve upon it; and provide an example where the toolset is applied to a realistic RTIC application, in the hopes of increasing the usage of RTIC and RTIC Scope. \todo{rephrase?}
The regulation of a complex dynamic system is chosen because an RTIC application for such a task is non-trivial, and it provides an ample opportunity to improve one's capabilities for control engineering.

*** Problem definition
:PROPERTIES:
:CUSTOM_ID: requirements
:END:
This thesis covers the development of an analysis toolset, RTIC Scope, that enables an RTIC application developer to gain non-invasive insight into the run-time of said application by exploiting the trace stream generated and exfiltrated by the debug facilities (see [[#debug-periphs]]) made available by the ARMv7-M standard, which RTIC supports by targeting Cortex-M platforms.

The set of /requirements/ RTIC Scope must fulfill within the scope of this thesis follows: RTIC Scope *MUST*[fn:: Interpreted as described in [[textcite:&rfc2119]].] be able to
1. <<req:itm-gen>> enable trace stream generation of hardware and software tasks (as defined by RTIC), and enable exfiltration of said trace stream from the device, by help of a target-side tracing library crate;
2. <<req:input>> read the generated trace stream via a hardware debugger or a serial device;
3. <<req:decode>> decode the trace stream to Rust structures;
4. <<req:rtic>> recover RTIC application metadata not contained within the trace stream;
5. <<req:timestamps>> associate timestamps to RTIC task events;
6. <<req:protocol>> report RTIC task events in real-time to the RTIC Scope end-user by use of a defined communication protocol.
7. <<req:dummy>> offer a reference implementation of a [[gls:frontend]] which implements the the protocol described in Requirement [[req:protocol]].
8. <<req:record>> record a trace to file which can be replayed offline; and
9. <<req:cargo>> be invoked as a ~cargo~ subcommand.

Delimitations to the above requirements apply, see [[#delimitations]].
*** Delimitations
:PROPERTIES:
:CUSTOM_ID: delimitations
:END:
In order to focus on the delivery of a robust toolset with proper implementation and documentation the scope of this thesis have been limited.
These /delimitations/[fn:: Uses the key words *MUST* and *SHOULD NOT* which are to be interpreted as described in [[textcite:&rfc2119]].], which are related to the requirements enumerated in [[#requirements]], are as follows:
1. Requirement [[req:itm-gen]]: RTIC Scope *MUST* apply the device mutations that are common to all ARM Cortex-M targets in order to enable trace stream generation and exfiltration. RTIC Scope *SHOULD NOT* apply device-specific mutations.
2. Requirement [[req:input]]: RTIC Scope *SHOULD NOT* have to ensure that a trace stream is read from the device; that responsibility falls upon the RTIC Scope end-user. However, RTIC Scope *MUST* fail or warn the end-user if it is unable to correctly decode the read data stream.
3. Requirement [[req:rtic]]: RTIC Scope *MUST* support RTIC version 1.0.0, see [[textcite:&rtic]].
   RTIC Scope *MUST* must recover metadata necessary to report the timestamped status of hardware and software tasks, as defined by RTIC.
4. Requirement [[req:protocol]]: The defined communication protocol *MUST* enable one-way communication from the ~cargo~ subcommand /backend/ to the reference /frontend/. The protocol *SHOULD NOT* enable two-way communication.

Following the above delimitations allows this thesis to be finished within an acceptable time frame[fn:: As defined by the author, i.e. not necessarily the recommended time frame as defined by the X7009E course taken at LuleÃ¥ Technical University during which this thesis is written.] and also to yield a documented code base which allows future development with minimal friction.

The use of the key words *MUST* and *SHOULD NOT* used above as to be interpreted as described in [[textcite:&rfc2119]].

# TODO describe that this paper only covers v0.3.0, except for the content of future work

*** Contributions
The development of RTIC Scope has yielded a number of [[gls:downstream]] contributions, namely a collection of crates:
- ~cargo-rtic-scope~ :: A ~cargo~ subcommand acting as the RTIC Scope backend (or host-side /daemon/) which fulfill Requirements [[req:input]]--[[req:protocol]] and [[req:record]]--[[req:cargo]].
  See [[#impl:cargo-rtic-scope]] and [[textcite:&rtic-scope:cargo-rtic-scope]].
- ~rtic-scope-frontend-dummy~ :: A reference implementation of a RTIC Scope frontend, which fulfill Requirement [[req:dummy]].
  See [[#impl:rtic-scope-frontend-dummy]] and [[textcite:&rtic-scope:dummy]].
- ~rtic-scope-api~ :: The communication protocol the ~cargo-rtic-scope~ uses to report RTIC task events in real-time to ~rtic-scope-frontend-dummy~, as described by Requirement [[req:protocol]].
  See [[#impl:api]] and [[textcite:&rtic-scope:api]].
- ~cortex-m-rtic-trace~ :: An auxilliary target-side crate that properly configure the device for trace stream generation and exfiltration, which fulfills Requirement [[req:itm-gen]].
  See [[#impl:rtic-trace]] and [[textcite:&rtic-scope:rtic-trace]].
- ~itm~ :: A library crate for decoding the trace stream exfiltrated from the embedded system, which fulfill Requirements [[req:decode]] and [[req:timestamps]] (partially).
  See [[#impl:itm]] and [[textcite:&itm]].

Of certain note it ~itm~ which ~cargo-rtic-scope~ relies on: its implementation does not rely on RTIC and can be used independently of RTIC Scope; ~itm~ can be used to decode trace stream generated by a target using an RTOS other than RTIC.
Because of this general nature and detachment from RTIC Scope it must not necessarily be a part of the RTIC Scope project itself, but is as of writing for reasons of convenience.
See [[#disc:itm-embedded-wg]] for a discussion on under what banner ~itm~ belongs.

Further, a number of [[gls:upstream]] contributions have been made to the crates which RTIC Scope depends on.
An exhaustive summary of these contributions are described below (listed in no particular order).

- ~probe-rs/probe-rs~ ::
  A "a modern, embedded debugging toolkit, written in Rust" [[parencite:&probe-rs]] utilized to fulfill Requirement [[req:input]].
  Contributions are:
  - /Reintroduce ~CargoOptions~ in ~mod common_options~/: patch set included in a larger refactor [[parencite:&pr:probe-rs:760]].
  - /arm: enable exception trace on ~setup_swv~/: improves tracing support for ARM targets [[parencite:&pr:probe-rs:758]].
  - /cargo: bump bitvec/: updates a dependency [[parencite:&pr:probe-rs:757]].
  - \textit{arm/itm: doc fields, enable global timestamps}: improves documentation [[parencite:&pr:probe-rs:728]].
  - \textit{Add generic probe/session logic from cargo-flash}: improves composability with RTIC Scope [[parencite:&pr:probe-rs:723]].
  - \textit{deprecate internal ITM/DWT packet decoder in favour of itm-decode}: replaces an unfinished internal trace stream decoder with an ~itm~ precursor; see [[#impl:itm]] [[parencite:&pr:probe-rs:564]].

  Refer to [[#impl:cargo-rtic-scope]] for a detailed description of the usage of this toolkit.
- ~probe-rs/cargo-flash~ ::
  A "cargo extension for programming microcontrollers" [[parencite:&cargo-flash]], functionality of which is used by ~cargo-rtic-scope~.
  Contributions are:
  - /move probe, session logic, flash downloader to probe-rs-cli-util/: moves functionality from ~cargo-flash~ to an auxilliary ~probe-rs~ library crate such that they can be utilized by ~cargo-rtic-scope~ [[parencite:&pr:cargo-flash:188]].

- ~rust-embedded/cortex-m~ :: A library crate that enables "low level access to Cortex-M processors" [[parencite:&cortex-m]], utilized to fulfill Requirement [[req:itm-gen]], [[req:decode]] and [[req:record]].
  Contributions are:
  - /scb: derive serde, Hash, PartialOrd for VectActive behind gates/: adds features used by ~itm~ [[parencite:&pr:cortex-m:363]].
  - /Implement various interfaces for trace configuration/: adds features used by ~cortex-m-rtic-trace~ [[parencite:&pr:cortex-m:342]].
  - \textit{TPIU: swo\textunderscore supports: make struct fields public, improve documentation}: fixes an issue in a library module and improves documentation [[parencite:&pr:cortex-m:381]].
  - /CHANGELOG: add missing items/: adds documentation about added features [[parencite:&pr:cortex-m:378]].
  - /itm: derive serde for \texttt{LocalTimestampOptions}, impl gated \texttt{TryFrom<u8>}/: adds features used by ~cargo-rtic-scope~  [[parencite:&pr:cortex-m:366]].
  - /ITM: check feature support during configuration, add busy flag, docs improvement/: ensures hardware support during trace stream generation configuration [[parencite:&pr:cortex-m:383]].

  Refer to [[#impl:rtic-trace]] and [[#impl:itm]] for a detailed description of the usage of this library.
- ~rtic-rs/rtic-syntax~ :: A crate that defines and parses the RTIC meta language [[parencite:&rtic-syntax]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - \textit{improve error string if parse\textunderscore binds is not set}: improves documentation when the crate is used as a library [[parencite:&pr:rtic-syntax:47]].
- ~rtic-rs/cortex-m-rtic~ :: The RTIC implementation for Cortex-M platforms [[parencite:&rtic]].
  Contributions are:
  - \textit{book/migration/v5: update init signature, fix example syntax}: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:480]].
  - /book: detail import resolving for 0.6 migration/: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:479]].
  - /book: update outdated required init signature/: improves RTIC examples in documentation [[parencite:&pr:rtic:478]].
- ~Michael-F-Bryan/include_dir~ :: A crate for embedding file trees in a binary [[parencite:&includedir]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - /Dir: add extract-to-filesystem functionality/: implements functionality for extracting embedded file trees to disk [[parencite:&pr:includedir:57]].
  - \textit{dir/extract: add mode for overwriting existing files}: implements functionality for overwriting existing files when extracting embedded file trees to disk [[parencite:&pr:includedir:65]].

*** Outline
 This paper is structured as follows
 - Introduction :: provides an introduction to Rust, RTIC, ARMv7-M hardware peripherals of interest, and the RTIC Scope project.
 - Previous work :: presents work previously done in the same domain, which this thesis builds upon.
 - Related work :: presents some tools similar to the features of RTIC Scope.
 - Implementation :: covers the implementation of RTIC Scope and the ~itm~ crate.
 - Results :: TODO
 - Discussion :: TODO
 - Conclusions :: TODO
 - Future work :: TODO
 - Appendices :: TODO

** Previous and Related Work
This chapter briefly covers previous work upon which RTIC Scope is based and related work.
*** Previous work
The implementation of RTIC Scope stands of the shoulders of countless developers that have enabled the implementation of the toolset within the frame of this thesis.
Notable libraries are referred to inline throughout this text.
When citing software, the three authors with the most contributions (in decreasing order) at the time of writing are cited as the authors of that software.
This is done for brevity.

*** Related work
Some toolsets similar to RTIC Scope were already available before the start of this thesis, namely:
- orbuculum :: an "[ARM] Cortex-M trace stream demuxer and post-processor" [[parencite:&orbuculum]];
- Percepio Tracealyzer :: a proprietary visual trace diagnostic tool that supports a multitude of platforms and [[acrshortpl:RTOS]] [[parencite:&tracealyzer]].
Neither of the above tools support [[ACRshort:RTIC]] at the time of writing.

** Theory
This chapter covers the theory, tools, and the ARMv7-M hardware features utilized in order to develop RTIC Scope.
*** ARMv7-M debug facilities
:PROPERTIES:
:CUSTOM_ID: debug-periphs
:END:
This section summarizes the hardware peripherals responsible for the generation and exfiltration of the [[ACRshort:ITM]] packet protocol.
The relationship of these perhipherals is also presented.
This section is not exhaustive for the sake of brevity;
for full information on each peripheral, refer to the respective sections in [[textcite:&arm-rm]].
See [[cref:theory:itm-proto]] for a description of the [[ACRshort:ITM]] packet protocol.

# DWT -> ITM -> TPIU -> ETB.
RTIC Scope utilizes the [[Acrfull:DWT]], [[Acrfull:ITM]], and [[Acrfull:TPIU]] peripherals for on-target trace generation and exfiltration.
The [[ACRshort:DWT]] and [[ACRshort:ITM]] peripherals are sources of [[ACRshort:ITM]] protocol packets which are forwarded to the [[ACRshort:TPIU]] for device exfiltration via serial communication.
The [[ACRshort:ITM]] muxes packets emitted by the [[ACRshort:DWT]] and generates timestamp packets in order to establish a timeline of events that occured on the traced target.
The relationship of these peripherals are visualized in [[cref:fig:debug-relations]].

# TODO properly do the below

#+BEGIN_src latex
  \begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 3cm, auto]

    \node[block] (dwt) {DWT};
    \node[block, right of=dwt] (itm) {ITM};
    \node[block, right of=itm] (tpiu) {TPIU};

    \path[->]
    (dwt) edge (itm)
    (itm) edge (tpiu);
  \end{tikzpicture}
  \label{fig:debug-relations}
  \caption{Relationship between ARMv7-M debug peripherals used in RTIC Scope.}
  \end{figure}
#+END_src

# #+NAME: fig:debug-relations
# #+CAPTION: Relationship between ARMv7-M debug peripherals. Copied from [[textcite:&arm-rm Figure C1-1]]. Utilization of the [[ACRshort:ETM]] peripheral is outside of the scope of this thesis; it's functions are disabled in the context of RTIC Scope v0.3.1.

**** [[Acrfull:DWT]]
# What does the DWT do and how do we use it?
The DWT peripheral concerns itself with hardware events and respond to these accordingly depending on the applied configuration.
For the purpose of RTIC Scope the DWT is configured to emit /hardware event packets/ on two types of events: when
- a configured range of memory is accessed (known as /data tracing/); and
- whenever the processor enters, exits, and returns to an exception handler (known as /exception tracing/).
Within this text the range of memory used for data tracing is referred to as a /watch address/.

Refer to [[textcite:&arm-rm C1.8]] for more information on the DWT unit.
**** [[Acrfull:ITM]]
:PROPERTIES:
:CUSTOM_ID: theory:itm-periph
:END:
# Summarize ITM functionality
The [[ACRshort:ITM]] unit is of an auxilliary nature; it has three functions:
- the multiplexing of hardware event packets from the [[ACRshort:DWT]] unit with its own packets which are then forwarded to the TPIU;
- control and generation of timestamp packets; and
- a memory-mapped register interface that allows logging of arbitrary data via a maximum of 256 stimulus registers, unused by RTIC Scope.

# Summarize the timestamp sources
Timestamp packets are sourced from a reference clock.
The reference clock is either the system clock, an asynchronous [[ACRshort:TPIU]] reference clock, or a /global timestamp clock/.
The frequencies and behavior of these reference clocks and how the target clock hierarchy is configured in general is wholly specific to each target and will thus not be covered in further detail.

# Summarize timestamp packets
Timestamp packets are appended to a set of non-timestamp packets that occur at a common timestamp and come in two forms: global and local.
# TODO when exactly is the time counting started?
Global timestamps are absolute and starts counting at the boot of the target device.
Local timestamps are relative to the last local timestamp and resets its count when a new one is generated.
An up-to-date absolute timestamp can be calculated by applying all local timestamp values upon the last global timestamp.
For example, if a global timestamp with the value $10$ is emitted after which two local timestamps with the respective values of $3$ and $4$ are emitted, an up-to-date absolute timestamp is calculated via $10 + 3 + 4 = 17$.
Local timestamps also contain information on the relationship between the local timestamp generation and the corresponding trace packets. The timestamp can be
- synchronous to the generated packets: the timestamp is the counter value when the non-timestamp packets were generated;
- delayed relative to the packets: the timestamp is the counter value when the timestamp packet was generated (the local timestamp value corresponding to the non-timestamp packet generation event is thus unknown, but must be between the previous and current local timestamp value);
- delayed relative to the associated event: synchronous to the generated packets, but the packets themselves were delayed because of other trace output packets; or
- delayed relative to the packets and associated event: a combination of the last two conditions.

# TODO explain what clock drives the global timestamp clock (P710)
# TODO document sync packets (P712)
# TODO document arbitration between packets from different sources (P713)

# TODO Instrumentation packets and RTIC resource tracing
# 32b per stim register, each has a FIFOREADY bit, each instrumentation packet contains at max 4B = 32b
# port number, 0-31

# XXX ITM stims has its own output buffer not related to the DWT output buffer, the status of the ITM output buffer can be queried via FIFOREADY in ITM_STIMx

# TODO add an example figure how a collection of back-to-back trace packets may look like. Timestamp is last in the chain

For more information on the ITM unit, refer to [[parencite:&arm-rm C1.7]]. For more information on global and local timestamps, refer to  [[parencite:&arm-rm C1-710]].
**** [[Acrfull:TPIU]]
# Summarize TPIU functionality
The TPIU provides external visibility of the trace packet stream by serializing...

by serializing these over a set of exposed hardware pins or via the MCU programmer unit (depending on target platform).
Depending on the platform, these can be GPIO pins which can be configured in parallel mode by use of multiple pins or a singular GPIO pin for an asynchronous port.

# Embedded Trace Buffer (ETB), SWO, or parallel trace port

For more information on the TPIU, refer to [[parencite:&arm-rm C1.10]].

# TODO recreate Fig. C1-1 from [[pdf:~/exjobb/thesis/docs/DDI0403E_d_armv7m_arm.pdf::713++0.00][DDI0403E_d_armv7m_arm.pdf: Page 713]] without ETM component.

# XXX The combination of the DWT and ITM packet stream and an asynchronous Serial Wire Output (SWO) is called a Serial Wire Viewer (SWV)
*** The [[ACRshort:ITM]] packet protocol
:PROPERTIES:
:CUSTOM_ID: theory:itm-proto
:END:
# TODO summarize the packet protocol and cover the packet types which we utilize
The [[ACRshort:ITM]] packet protocol is used by RTIC Scope to garner insight about the executing RTIC application.
This protocol defines packets that contain a one-byte /header/, which describes what type of data a certain packet contains; how long the packet /payload/ is, a byte multiple; and the packet payload.
Some headers also contain payload.
The protocol effectively implements a [[acrfull:TLV]] encoding sheme.
This section covers the packet types that RTIC Scope exploits and provide graphical representations ([[crefrange:fig:lts1,fig:data-trace-packet]]) of these packets, sourced from [[textcite:&arm-rm]].
Within all of these representations, the /C/ flag indicate whether a decoder should interpret the next byte in the trace stream as a part of the current packet;
if C is not set, the next byte in the stream is a header for the next packet.

For other packets, and a full description of the protocol, see [[textcite:&arm-rm Appendix D4]].

RTIC Scope v0.3.1 concerns itself with six packets:
- [[acrfull:GTS1]] :: A timestamp packet containing the lower 26 bits of the /absolute/ timestamp.
- [[acrfull:GTS2]] :: A timestamp packet containig the upper 22 or 38 bits of the /absolute/ timestamp, depending on the hardware implemenation.
- [[acrfull:LTS1]] :: A multi-byte timestamp packet containing the /relative/ timestamp.
- [[acrfull:LTS2]] :: A single-byte timestamp packet containing the /relative/ timestamp.
- Exception trace packet :: A hardware-event packet describing the status of an interrupt handler.
- Data trace data value packet format :: A hardware-event packet describing the value read or written to a watch address monitored by a [[ACRshort:DWT]] comparator.

Timestamp packets come in two types: /absolute/ and /relative/.
Both types derive their timestamps from a reference clock (see [[cref:theory:itm-periph]]):
/absolute/ timestamps denote how many ticks this clock have tocked ever since it began; and
/relative/ timestamps denote how many ticks this clock have tocked ever since the last relative timestamp.
When a relative timestamp is generated, the relative timestamp is then reset.
This type separation is done in order to decrease the required bandwidth to communicate the time on the system.
Absolute and relative timestamps are further divided into a total of four different packets, summarized above and detailed below.

Global timestamps come in three flavour: 48-bit, 64-bit, or not at all (omitted).
Whether global timestamp support is implemented, and the size of this timestamp, depends on the hardware implementation of the [[ACRshort:ITM]].

The two packets that constitute a global timestamp, [[ACRshort:GTS1]] and [[ACRshort:GTS2]], are sent seperately and not necessarily in order.
A [[ACRshort:GTS2]] packet is not emitted unless any of the bits in the 26--47 or 26--64 range have changed.
The [[ACRshort:GTS1]] packet also contains two flags aside from the lesser significant 25 bits:
- /ClkCh/ :: Set if the system which the [[ACRshort:ITM]] is tracing has changed clock input to the processor since the last global timestamp packet.
  A full global timestamp follows in the stream if this flag is set.
- /Wrap/ :: Set if the more significant bits above the 25th have changed since the last [[ACRshort:GTS2]] packets.
  This flag indicates that the [[ACRshort:GTS1]] should be recorded until the next [[ACRshort:GTS2]] is received so that the full timestamp can be decoded.
[[cref:fig:gts1]], [[cref:fig:gts2-48]], and [[cref:fig:gts2-64]] visually describes the [[ACRshort:GTS1]], [[ACRshort:GTS2]] (48-bit) and [[ACRshort:GTS2]] (64-bit) packets, respectively.

Global timestamps can be generated periodically; or after each packet, if space is available in the queue.

#+NAME: fig:gts1
#+CAPTION: [[ACRshort:GTS1]] packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-7]].
[[file:svgs/gts1.pdf]]
#+NAME: fig:gts2-48
#+CAPTION: [[ACRshort:GTS2]] 48-bit packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-8]].
[[file:svgs/gts2-48.pdf]]
#+NAME: fig:gts2-64
#+CAPTION: [[ACRshort:GTS2]] 64-bit packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-9]].
[[file:svgs/gts2-64.pdf]]

The two local timestamps, [[ACRshort:LTS1]] and [[ACRshort:LTS2]], are not complementary:
instead they supply a different maximum relative timestamp.
[[ACRshort:LTS1]] provide a relative timestamp value that can be represented with 28 bits and is between 2--5 bytes long (header included).
[[ACRshort:LTS2]] is a single-byte packet with a relative timestamp that can be represented with 3 bits is provided in the header.
More specifially, an [[ACRshort:LTS2]] can represent a relative timestamp value of 1--6;
clashes with headers for other types of packets would occur if the value was 0 or 7.
[[ACRshort:LTS1]] also contain a 2-bit /TC/ field which describes the relationship of the timestamp value with the corresponding non-timestamp packet(s).
This flag have four possible values:
- TC $=$ 0b00 :: /Synchronous/: the timestamp value denotes the time when the non-timestamp packet was generated.
- TC $=$ 0b01 :: /Delayed relative/: the timestamp value denotes the time when the timestamp packet itself was generated.
  The synchron ous timestamp is here unknown, "but must be between the previous and current timestamp values".
- TC $=$ 0b10 :: Synchronous, but the corresponding non-timestamp packet generation was "delayed relative to the associated event".
- TC $=$ 0b11 :: ...
[[ACRshort:LTS2]] packets are always synchronous.

# TODO? in impl: current implementation (dummy) assumes local timestamps are all sync. time restriction.

Local timestamps are emitted after the corresponging non-timestamp packets.
For example, if the sequence reads
1. data packet 1;
2. [[ACRshort:LTS1]];
3. data packet 2;
4. data packet 3; and
5. [[ACRshort:LTS2]],
then the [[ACRshort:LTS1]] corresponds to data packet 1;
and [[ACRshort:LTS2]] corresponds to data packet 2 and 3, which occured within the same tick of the [[ACRshort:TPIU]] reference clock.
# TODO confirm this? [fn:: unconfirmed]? [fn:: author's interpretation]? can we ask ARM?

#+NAME: fig:lts1
#+CAPTION: [[ACRshort:LTS1]] packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-4]].
[[file:svgs/lts1.pdf]]
#+NAME: fig:lts2
#+CAPTION: [[ACRshort:LTS2]] packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-6]].
[[file:svgs/lts2.pdf]]

The exception trace packet ([[cref:fig:exception-packet]]) describes the state of the system's interrupt handlers and are emitted upon a state change.
Its payload contains two fields:
- /ExceptionNumber/ :: A 7-bit field describing which interrupt handler changed state.
  This field it decoded via [[cref:tbl:irqns]].[fn:exception-number-0]
- /FN/ :: A 2-bit field describing the action taken by the processor regarding the interrupt handler.
  This field can have three possible values:
  - FN $=$ 0b01 :: the exception was entered;
  - FN $=$ 0b10 :: the exception was exited; and
  - FN $=$ 0b11 :: the exception was returned to.
    This action indicates that exception was previously preempted by an exception of higher priority which has now exited.
  *FN $=$ 0b00* is a reserved value.

#+NAME: fig:exception-packet
#+CAPTION: Exception trace packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-16]].
[[file:svgs/exception-trace.pdf]]
#+CAPTION: ARMv7-M Exception/IRQ numbers and names. Redrawn from [[parencite:&arm-rm Table B1-4]], with additional emphasis on $N$.
#+NAME: tbl:irqns
| Exception number | Exception name/label   |
|------------------+------------------------|
|                1 | Reset                  |
|                2 | NMI                    |
|                3 | HardFault              |
|                4 | MemManage              |
|                5 | BusFault               |
|             7-10 | Reserved               |
|               11 | SVCall                 |
|               12 | DebugMonitor           |
|               13 | Reserved               |
|               14 | PendSV                 |
|               15 | SysTick                |
|               16 | External interrupt 0   |
|                . | .                      |
|                . | .                      |
|                . | .                      |
|         16 + $N$ | External interrupt $N$ |
|------------------+------------------------|

The data trace data value packet format packet ([[cref:fig:data-trace-packet]]), henceforth referred to as the "data trace packet", are emitted when the processor accesses data in memory as a consequence of appropriate [[ACRshort:DWT]] comparator configuration (see [[cref:impl:rtic-trace]]).
The payload contains three fields of information:
- /CMPN/ :: A 2-bit identifier of the [[ACRshort:DWT]] comparator which matched the configured address access.
  This identifier is the same as the comparator offset specified in [[cref:impl:rtic-trace]].
- /WnR/ :: A flag describieng whether the access was a read (not set) or write (set).
- /VALUE/ :: The value that was written to the address.
  The length of VALUE is the same number of bytes accessed by the target hardware.
  If only a single byte is read/written by the target, then VALUE is also one byte long.

#+NAME: fig:data-trace-packet
#+CAPTION: Data trace data value packet format, copied with permission (?) from [[textcite:&arm-rm Figure D4-22]].
[[file:svgs/data-trace.pdf]]
*** Tracing [[ACRshort:RTIC]] tasks
# How tasks are traced, summarized
Because RTIC implements tasks by use of exception handlers it is only natural to exploit exception tracing in order to trace the tasks abstracted above them.
This approach is however only directly applicable to hardware tasks which dedicate a handler for each task.
Software tasks are implemented with an additional layer of abstraction above handlers by use of task dispatchers, as covered in [[cref:rtic]].
If exception tracing is employed to trace software tasks such a trace packet would only describe that one of the potentially multiple software tasks handled by one dispatcher changed state.
Instead, a unique identifier is assigned to each software task and written to a data traced memory range when the task enters and exits.

** Implementation
This chapter covers the implementation of ~cargo-rtic-scope~, ~cortex-m-rtic-trace~, and ~rtic-scope-frontend-dummy~ of RTIC Scope and the implementation of ~itm~.
The implementation is presented in a downstream manner, similar to the order in which the RTIC Scope crates are applied.
That is, how
1. ~cortex-m-rtic-trace~ is applied and what it does;
2. ~cargo-rtic-scope~ recovers metadata from the RTIC application and how it reads the raw trace stream from the source;
3. ~itm~ decodes this stream into manageable Rust structures;
4. ~cargo-rtic-scope~ recovers RTIC metadata for the decoded trace stream;
5. this resolved trace stream is forwarded to frontends; and
6. how a frontend handles a trace stream.

As mentioned in [[cref:delimitations]], this chapter covers the v0.3.0 of RTIC Scope.

# TODO dedicated section for the replay verb

# TODO list a whole RTIC application example here somewhere that we can keep referring to?

\missingfigure{Draw the data flow in RTIC Scope: DWT to ITM to TPIU to cargo-rtic-scope and the itm crate, to replay file and frontends.}

*** ~cortex-m-rtic-trace~ and its application
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace
:END:
~cortex-m-rtic-trace~ is an auxilliary target-side crate that configures all relevant Cortex-M peripherals --- namely the [[acrfull:DCB]][fn:: A component of the [[acrfull:SCB]] peripheral.], [[ACRshort:TPIU]], [[ACRshort:DWT]], and [[ACRshort:ITM]] -- for tracing.
The crate exposes two functions:
- ~cortex_m_rtic_trace::configure~ :: a regular Rust function for configuration of the peripherals mentioned above; and
- ~cortex_m_rtic_trace::trace~ :: a Rust macro with with to trace software tasks.
Henceforth, within this section, these two functions will be referred to as ~configure~ and ~trace~, respectively.

This section is divided into two parts: [[cref:impl:rtic-trace:peripheral-config]], which covers the application of ~configure~; and [[cref:impl:rtic-trace:trace-macro]], which covers the application of the ~trace~ macro.

It is important to point out that ~cortex-m-rtic-trace~ is a crutch which incurs unecessary overhead for the end-user.
On the RTIC Scope roadmap is thus the eventual deprecation of this crate. See [[cref:fut:rm-rtic-trace]] for more on this topic.

**** Peripheral configuration
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:peripheral-config
:END:
After applying device-specific configurations for trace generation, and querying the frequency of the [[ACRshort:TPIU]] reference clock, ~configure~ is applied as shown in [[cref:lst:rtic-trace:configure]].
#+NAME: lst:rtic-trace:configure
#+CAPTION: Example application of ~cortex_m_rtic_trace::configure~.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      // device-specific configurations for trace stream generation...

      let freq = {
          // device-specific query for the TPIU reference clock
          // frequency...
      };

      use cortex_m_rtic_trace::{
          self, GlobalTimestampOptions, LocalTimestampOptions, TimestampClkSrc,
          TraceConfiguration, TraceProtocol,
      };

      // configure device-common tracing
      cortex_m_rtic_trace::configure(
          &mut ctx.core.DCB,
          &mut ctx.core.TPIU,
          &mut ctx.core.DWT,
          &mut ctx.core.ITM,
          1, // task enter DWT comparator ID
          2, // task exit DWT comparator ID
          &TraceConfiguration {
              delta_timestamps: LocalTimestampOptions::Enabled,
              absolute_timestamps: GlobalTimestampOptions::Disabled,
              timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
              tpiu_freq: freq, // Hz
              tpiu_baud: 9600, // B/s
              protocol: TraceProtocol::AsyncSWONRZ,
          },
      )
      .unwrap();

      // ...
  }
#+end_src

~configure~ in [[cref:lst:rtic-trace:configure]] does a number of things in the following order:
1. <<rtic-trace:conf-protocol>> ensures that the target's [[ACRshort:TPIU]] peripheral supports the requested ~protocol~ by reading the [[acrfull:TPIU_TYPE]] [[parencite:&arm-rm C1.10.6]];
2. ensures that the user did not request an invalid [[ACRshort:TPIU]] configuration (i.e. =tpiu_freq: 0= or =tpiu_baud: 0=);
3. <<rtic-trace:conf-exception-trace>> ensures that the target's [[ACRshort:DWT]] peripheral supports exception tracing by reading the /NOTRCPKT/ bit in [[acrfull:DWT_CTRL]] [[parencite:&arm-rm C1.8.7]];
4. <<rtic-trace:nofail-conf>> configures the [[ACRshort:DCB]], [[ACRshort:TPIU]], and [[ACRshort:DWT]] peripherals (partially):
   1. sets the /TRCENA/ bit in the [[acrfull:DCB_DEMCR]], a "global enable for all [[ACRshort:DWT]] and [[ACRshort:ITM]] features";
   2. calculates and writes a prescaler to the /SWOSCALER/ bitrange in the [[acrfull:TPIU_ACPR]] such that the [[ACRshort:TPIU]] communicates with a requested baud rate.
      The prescaler is calculated via [[cref:eq:prescaler]] as derived from [[textcite:&arm-rm C1.10.4]].[fn:: This configuration implementation is faulty. See [[cref:fut:swoscaler]].]
      #+NAME: eq:prescaler
      \begin{equation}
      \frac{\texttt{tpiu\textunderscore freq}}{\texttt{tpiu\textunderscore baud}} - 1
      \end{equation}
   3. drops any [[acrfull:ETM]] packets that the [[ACRshort:TPIU]] receives because the utilization of these packets are outside the scope of this thesis; and
   4. sets the /EXCTRCENA/ bit in [[acrshort:DWT_CTRL]] which enables the generation of exception traces in the [[ACRshort:DWT]] [[parencite:&arm-rm C1.8.7]].
5. <<rtic-trace:itm>> Applies [[ACRshort:ITM]]-related options given to ~configure~ by writing to the [[acrfull:ITM_TCR]] while also checking for target support for the requested configuration [[parencite:&arm-rm C1.7.6]]:
   1. sets the /ITMENA/, /TXENA/, /SWOENA/, and /TSENA/ bits which enables the [[ACRshort:ITM]], forwards trace packets from the [[ACRshort:DWT]] to the [[ACRshort:ITM]], "enables asynchronous clocking of the timestamp counter", and enables the generation of local timestamps, respectively;
   2. writes 0 to the /TraceBusID/ field because RTIC Scope does not support multi-source tracing within the scope of this thesis[fn:: Writing 0 to this field is potentially invalid. See [[cref:fut:TraceBusID]].]
   3. writes 0 to the /TSPrescale/ field, disabling prescaling for local timestamps; and
   4. writes 0 to the /GTSFREQ/ field, disabling global timestamps.[fn:: Global timestamps are an optional feature, and is not supported by all Cortex-M targets.]
6. <<rtic-trace:dwt>> Configures [[ACRshort:DWT]] comparators for software task tracing:
   1. first, resolves the target addresses of two =u32= /watch variables/ which live in [[gls:elf:data]];
   2. dereferences two [[ACRshort:DWT]] comparators as specified by the 5th and 6th arguments to ~configure~ in [[cref:lst:rtic-trace:configure]];[fn:: The [[ACRshort:API]] for specifying these comparators can be greatly improved. See [[cref:fut:dwtcomps]].]
   3. configures the first comparator to signal a match (and generate an associated trace stream packet) when data is written to the first watch variable:
      1. writes to seven fields in the [[acrfull:DWT_FUNCTIONn]][fn:dwt-n] [[parencite:&arm-rm C1.8.17]], where $n$ is the offset of the comparator (in the context of [[cref:lst:rtic-trace:configure]], $1$):
         0b1101 to /FUNCTION/, configuring the comparator to match on address access;
         0 to /EMITRANGE/, disabling trace address packet generation;[fn:: We are not interested in the address that contains the watch variable.]
         0 to /DATAVMATCH/, to disable data value comparison;
         0 to /CYCMATCH/, to disable cycle counter comparison;
         and 0 to /DATAVSIZE/, /DATAVADDR0/, and /DATAVADDR1/ because these fields are [[acrfull:SBZ]] [[parencite:&arm-rm Glossary-855]] in address comparison context.
      2. writes the first watch variable address to [[acrfull:DWT_COMPn]][fn:dwt-n] (with $n = 1$), in order for the comparator to match on that address access; and
      3. writes 0 to [[acrfull:DWT_MASKn]][fn:dwt-n] ($n=1$), such that the comparator does not match on a range of addresses.
   4. Lastly, the second comparator is configured in the same manner as the first, but with the second watch variable address in mind and $n=2$.

If any step in [[crefrange:rtic-trace:conf-protocol,rtic-trace:conf-exception-trace]] fails ~configure~ prematurely returns an ~Err(_)~ that signals what went wrong, and no peripheral configuration will have been applied: the target will be in the same state as before ~configure~ was called.

Several fields in [[ACRshort:ITM_TCR]] are potentially [[acrfull:RAZ-WI]], [[acrfull:RAZ]], or [[acrfull:RAO]] [[parencite:&arm-rm Glossary-854]] in order to signal hardware support.
This requires the field to be read after a write to ensure that a configuration was applied.
During the steps in [[cref:rtic-trace:itm]], if any read-back values does not match what was written, ~configure~ prematurely returns an ~Err(_)~ signalling what configuration component was not supported by the target and what components have been successfully applied, notifying the end-user that a partial configuration has now been applied.
It is up to the end-user to reset the target to the state before ~configure~ was called.
For a discussion on this implementation detail, see [[textcite:&issue:cortex-m:382]].

The steps in \cref{rtic-trace:nofail-conf,rtic-trace:dwt} and cannot fail.

Of certain note are the steps in [[cref:rtic-trace:dwt]] because of the dependency of variables in ~.data~ to trace software tasks, and how the watch variables in this section are aligned in memory.
The [[ACRshort:DWT]] comparators are configured to match on writes to singular addresses which are represented as =u32= variables.
However, due to performance reasons, the watch variables are represented as =u8= variables: only a single byte will be written to these 32-bit addresses during run-time tracing (see [[cref:impl:rtic-trace:trace-macro]]).
Further, because of time constrains no experimentation has been done with a non-zero mask: this requires the watch variables to be aligned to 32-bits. For more on the topic of performance, see [[cref:disc:perf]] and [[cref:fut:opt-dwt-units]].
\todo{improve this paragraph.}

**** Tracing software tasks with ~trace~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:trace-macro
:END:
~trace~ is an optional macro that is only required if software task tracing is wanted.
It's application is trivial, but requires that ~config~ executed successfully.
To trace a software task, consider [[cref:lst:rtic-trace:trace]] which defines two tasks: =task1= and =task2=.
Of the two tasks, =task2= is traced by simply decorating it with =#[trace]=, the invocation of the =trace= macro.
#+NAME: lst:rtic-trace:trace
#+CAPTION: Application example of the ~trace~ macro. ~task2~ is traced; ~task1~ is not.
#+begin_src rust
  // ...

  use cortex_m_rtic_trace::{self, trace};

  #[task]
  fn task1(_: task1::Context) {}

  #[task]
  #[trace]
  fn task2(_: task2::Context) {}

  // ...
#+end_src

Consider now [[cref:lst:rtic-trace:trace-expanded]], which is the result of expanding the macros applied in [[cref:lst:rtic-trace:trace]] via ~cargo-expand~ [[parencite:&cargo-expand]].
#+NAME: lst:rtic-trace:trace-expanded
#+CAPTION: Application example of the ~trace~ macro after macro expansion via ~cargo-expand~. Unrelated expansions omitted.
#+begin_src rust
  // ...
  use cortex_m_rtic_trace::{self, trace};
  // ...
  #[allow(non_snake_case)]
  fn task1(_: task1::Context) {
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
  }
  #[allow(non_snake_case)]
  fn task2(_: task2::Context) {
      ::cortex_m_rtic_trace::__write_enter_id(0);
      use rtic::Mutex as _;
      use rtic::mutex_prelude::*;
      ::cortex_m_rtic_trace::__write_exit_id(0);
  }
  // ...
#+end_src

*** Recording a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope
:END:
~cargo-rtic-scope~ is a host-side daemon that fulfills [[crefrange:req:input,req:protocol]] and [[crefrange:req:record,req:cargo]].
It is run like a ~cargo~ subcommand, as seen in [[cref:lst:cargo-rtic-scope:summary]], where ~<verb>~ is either ~trace~ or ~replay~.
As the verbs imply, ~trace~ is used to trace the execution of an RTIC application on the target and ~replay~ is used to replay a trace for post-mortem analysis.
#+NAME: lst:cargo-rtic-scope:summary
#+CAPTION: Summary of ~cargo-rtic-scope~ invocation.
#+begin_src shell
  $ cargo rtic-scope [options...] <verb> [options...]
#+end_src

This section covers the options and implementation of the ~trace~ verb.

**** Section overview
The implementation responsible for recording and presenting a trace to the end-user is covered in 10 parts.
These parts are enumerated below.

1. Building the RTIC application, [[cref:impl:cargo-rtic-scope:building-rtic-app]].
2. Reading options from the cargo maniest, [[cref:impl:cargo-rtic-scope:read-manifest]].
3. Creating a trace file, [[cref:impl:cargo-rtic-scope:create-trace-file]].
4. Generating metadata maps, [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].
5. Spawning frontends, [[cref:impl:cargo-rtic-scope:spawning-frontends]].
6. Reading the trace from the target, [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]].
7. Flashing the target, [[cref:impl:cargo-rtic-scope:flash-target]].
8. Flushing trace metadata to file, [[cref:impl:cargo-rtic-scope:flush-metadata]].
9. Resetting the target, [[cref:impl:cargo-rtic-scope:reset-target]].
10. Tracing the target, [[cref:impl:cargo-rtic-scope:trace-target]].

**** Building the RTIC application
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:building-rtic-app
:END:
The first step is to build the RTIC application the end-user wants to trace.
This is done as a preparatory stage for [[cref:impl:cargo-rtic-scope:generating-metadata-maps]], [[cref:impl:cargo-rtic-scope:create-trace-file]] and [[cref:impl:cargo-rtic-scope:flash-target]];
and logically, if the application cannot be built, it cannot be traced.
An additional side-effect of building the RTIC application is the possibility of executing ~cargo rtic-scope trace~ like one would execute ~cargo run~.

The application is built via [[cref:lst:cargo-rtic-scope:build]], where ~OPTIONS~ are optional additional flags to forward to ~cargo~ from the invocation of ~cargo rtic-scope trace~.
#+NAME: lst:cargo-rtic-scope:build
#+CAPTION: The build process of RTIC Scope. ~OPTIONS~ is a set of additional flags potentially forwarded by ~cargo-rtic-scope~.
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi [OPTIONS...]
#+end_src
For example, if the current crate would yield multiple binaries on build, ~cargo rtic-scope trace~ must know the singlar binary which the end-user wants to trace.
Specifying this flag is done in the same way as for ~cargo build~: via ~--bin~.
[[cref:lst:cargo-rtic-scope:build-bin]] contains an example use of this option, which would yield the ~cargo build~ invocation in [[cref:lst:cargo-rtic-scope:build-bin-forwarded]].
#+NAME: lst:cargo-rtic-scope:build-bin
#+CAPTION: Invocation of ~cargo rtic-scope trace~ with the optional ~--bin~ option which is forwarded to the underlying ~cargo build~ invocation, where ~OPTIONS~ is a set of additional flags and/or options potentially set by the end-user; not all of which are necessarily forwarded.
#+begin_src shell
  $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...]
#+end_src
#+NAME: lst:cargo-rtic-scope:build-bin-forwarded
#+CAPTION: The underlying ~cargo build~ invocation as a result of executing [[cref:lst:cargo-rtic-scope:build-bin]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...]
#+end_src

Below are a description of the flags and options the end-user can specify during the invocation of ~cargo rtic-scope trace~ (in the same manner as ~cargo build~) that are forwarded to the underlying ~cargo build~ invocation in [[cref:lst:cargo-rtic-scope:build]].
- ~--bin <binary>~ :: Used to specify which singlar binary to build.
- ~--example <example>~ :: Used to build a singular example binary instead of a non-example binary.
- ~--package <package>~ :: Used to build a crate instead of a singlar binary inside of a crate.
  This crate should yield a single binary.
- ~--release~ :: Used to build the binary in release mode instead of debug mode. Optimizations are applied during build with this flag.
- ~--target <target-triple>~ :: Used to specify the target platform for which the binary should be built for. This option can be used to override the default target triple, or the one specified via the ~/.cargo/config{,toml}~ files.
- ~--manifest-path <path>~ :: Used to override the default path to the ~cargo~ manifes, ~Cargo.toml~.
- ~--no-default-features~ :: Used to disable all default features of the crate that contains the singular binary.
- ~--all-features~ :: Used to enable all features of the crate that contains the singular binary.
- ~--features <feat1>[,feat2[,feat3[...]]]~ :: Used to specify the set of features to enable of the crate that contains the singular binary.

The above flags and options were deemed as the most common flags an end-user would want to specify when building the RTIC application.
If the user wants to specify an option or flag that is not among the above set the sentinel ~--~ can be used.
For example, if the end-user invokes [[cref:lst:cargo-rtic-scope:sentinel]], ~cargo-rtic-scope~ invokes [[cref:lst:cargo-rtic-scope:sentinel-forwarded]].
#+NAME: lst:cargo-rtic-scope:sentinel
#+CAPTION: Example ~cargo rtic-scope trace~ incovation with an arbitrary ~cargo build~ argument.
#+begin_src shell
    $ cargo rtic-scope trace --bin my-rtic-application [OPTIONS...] -- --some-cargo-build-flag
#+end_src
#+NAME: lst:cargo-rtic-scope:sentinel-forwarded
#+CAPTION: Resulting ~cargo build~ incovation on [[cref:lst:cargo-rtic-scope:sentinel]].
#+begin_src shell
  $ cargo build --message-format=json-diagnostic-rendered-ansi --bin my-rtic-application [OPTIONS...] --some-cargo-build-flag
#+end_src
This approach ensures that the end-user can always build the RTIC application with any set of valid ~cargo build~ flags and options.

The effect of building the binary with =--message-format=json-diagnostic-rendered-ansi= is that the otherwise human-readable output of ~cargo build~ is instead in [[gls:JSON]], a machine-readable format.
This JSON output describes all artifacts that are built, including the singular binary that the end-user wants to trace, for which ~cargo build~ tells us the path to the built binary used to flash the target in [[cref:impl:cargo-rtic-scope:flash-target]];
the path to the root of the crate that this binary lives, used in [[cref:impl:cargo-rtic-scope:create-trace-file]];
and the path to the source file of this binary, used in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]].

The JSON is not parsed directly, but via ~cargo_metadata~ [[parencite:&cargo-metadata]].

**** Reading options from the ~cargo~ manifest
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:read-manifest
:END:
The operation of ~cargo rtic-scope trace~ requires some information about the RTIC application from the end-user.
These are specified in the metadata block of the crate's manifest, ~Cargo.toml~.
One may for example write the information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]].
#+NAME: lst:cargo-rtic-scope:manifest-metadata-example
#+CAPTION: Example of required user-supplied information in crate manifest, ~Cargo.toml~.
#+begin_src text
  $ cat Cargo.toml
  [...]

  [package.metadata.rtic-scope]
  pac_name = "atsamd51n"
  pac_features = []
  pac_version = "0.11"
  interrupt_path = "atsamd51n::Interrupt"
  tpiu_freq = 12000000
  tpiu_baud = 38400
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1
  expect_malformed = false

  [...]
#+end_src
Of these fields the below are utilized in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]]:
- ~pac_name~,
- ~pac_features~,
- ~pac_version~,
- ~interrupt_path~,
- ~dwt_enter_id~,
- ~dwt_exit_id~;
and the below fields are utilized in  [[cref:impl:cargo-rtic-scope:reading-the-trace-stream]] and  [[cref:impl:itm]]:
- ~tpiu_freq~,
- ~tpiu_baud~,
- ~lts_prescaler~.
The last flag, ~expect_malformed~ is a debug option utilized in [[cref:impl:cargo-rtic-scope:trace-target]].
For a description of each field, see the respective sections.

The fields of information in [[cref:lst:cargo-rtic-scope:manifest-metadata-example]] are read from ~Cargo.toml~ by help of ~cargo_metadata~ [[parencite:&cargo-metadata]] and ~serde_json~ [[parencite:&serde-json]].

# TODO reformat the below
The last piece of the puzzle is from where to source user-supplied information.
Four fields of information is required to complete the second step above: the PAC name, version, features (if any), and the path to the =PAC::Interrupt= enum.
There are two methods the user can supply this information: via commandline options, see [[lst:recovery-user-info-cmdopt]];
or by entering the fields into the ~rtic-scope~ metadata block of the application's ~Cargo.toml~, see [[lst:recovery-user-info-toml]].
PAC information in ~Cargo.toml~ is persisent, and simplifies an iterative workflow.

#+NAME: lst:recovery-user-info-cmdopt
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via command line options.
#+begin_src shell
  $ cargo rtic-scope trace --pac-name stm32f4 --pac-version 0.13 --pac-features stm32f401 --pac-features some-other-feature --interrupt-path "stm32f4::stm32f401::Interrupt"
#+end_src

#+NAME: lst:recovery-user-info-toml
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via ~Cargo.toml~ metadata.
#+begin_src toml
# ...

[package.metadata.rtic-scope]
pac_name = "stm32f4"
pac_features = ["stm32f401", "some-other-feature"]
pac_version = "0.13"
interrupt_path = "stm32f4::stm32f401::Interrupt"

# ...
#+end_src

**** Creating a trace file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:create-trace-file
:END:
To enable port-mortem analysis of a traced RTIC application the recorded trace must be saved to disk.
The build step (see [[cref:impl:cargo-rtic-scope:building-rtic-app]]) yields the crate root of the traced application.
A natural directory in which to save trace files is then under ~/target/~ which contains all build artifacts of the crate.
For purposes of separation trace files are saved under the ~rtic-traces~ sub-directory; the full path to this directory is then ~/target/rtic-traces/~.
While this directory is meant for ephemeral artifacts (of which recorded traces may not belong) it was the simplest approach to associate traces to a particular crate (including its state; see below) while also not writing files to a wholly unexpected directory (e.g. the crate root directory).

Of note is that ~/target/~ is removed if ~cargo clean~ is executed.
It is thus up to the RTIC Scope end-user to ensure that traces of interests are saved to a persistent location.
For this purpose the optional ~--trace-dir <dir>~ option overrides the output directory of the trace files.

The trace filename contains three sections of information:
- the name of the RTIC application :: to help with the seperation of a crate that potentially contains more than one binary;
- the git revision of the local repository :: to associate the trace with the source code of the traced RTIC application; and
- a second-accurate timestamp :: to associate the trace with MCU-external events (e.g. conditions of the environment in which the application is traced).

After some tracing and development during January 13th and 14th, 2022, the trace directory could for example contain the files in [[cref:lst:cargo-rtic-scope:trace-example-files]].
#+NAME: lst:cargo-rtic-scope:trace-example-files
#+CAPTION: Example of trace filenames after two traces. ~blinky~ is the name of the RTIC application binary; ~g124b3c5~ the git revision; and the remainder (sans ~.trace~) is the timestamp of the trace. The second trace file was recoded from an RTIC application with uncommitted changes, hence the ~-dirty~ suffix to the git revision.
#+begin_src text
  $ ls -ogh target/rtic-traces
  total 8.0K
  -rw-r--r-- 1 1.5K Jan 13 16:54 blinky-g124b3c5-2022-01-13T16:54:00.trace
  -rw-r--r-- 1 1.3K Jan 14 18:38 blinky-g124b3c5-dirty-2022-01-14T18:37:57.trace
#+end_src

In case two ~cargo rtic-scope trace~ instances are executed within the span of one second without any changes to the git repository the same trace filename will be generated twice; this will be caught by the second instance which will exit with an error: ~cargo-rtic-scope~ cannot overwrite trace files.
Trace files can however be explicitly deleted:
if the user wants to record a trace and remove all previously recoded traces in the trace directory ~--clear-traces~ can be specified.
This flag only deletes files with the ~.trace~ file extension.

**** Generating metadata maps
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:generating-metadata-maps
:END:
# Introduction: we must translate raw ITM data to RTIC run-time information.
As covered in [[cref:theory:itm-proto]], the [[ACRshort:ITM]] packet protocol is used to trace hardware and software tasks.
This protocol is not designed with RTIC in mind:
instead of information that can be directly associated to an RTIC tasks the protocol tells us the number of the [[ACRshort:DWT]] comparator that signaled a write to a watch address along with the data written, used to signal a software task enter or exit;
and the IRQ number of the interrupt handler that entered, exited or was returned to, used to signal a hardware task enter or exit.
These pieces of information must be associated back to the RTIC tasks responsible for their emission in a preparatory /recovery step/.
This section covers this step which is divided into two parts:
1. the generation of the =recovery::HardwareMap=, [[cref:impl:hardware-map]]; and
2. the generation of the =recovery::SoftwareMap=, [[cref:impl:software-map]].
Together these two lookup maps constitute the full =recovery::TraceLookupMaps= which is used by =recovery::TraceMetadata= in order to fulfill Requirement [[req:rtic]].

***** Generating the ~recovery::HardwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:hardware-map
:END:
# Overview: what to we need?
In order to generate a =recovery::HardwareMap= the RTIC application declaration must be parsed.
This is already done when the RTIC application is built in [[cref:impl:cargo-rtic-scope:building-rtic-app]] when the =rtic::app= macro is expanded via =rtic_syntax::parse{,2}= [[parencite:&rtic]].
This expansion operation yields an =rtic_syntax::App= [[parencite:&rtic-syntax]] used internally to verify the application declaration and yield the expanded code.
This structure contains all the information ~cargo rtic-scope trace~ requires (see below) but is not emitted during the building step.
This requires the application declaration to be parsed an additional time which requires knowledge about the location of the source code file.
Fortunately, this knowledge is acquired in the build step.

# We must the source for the ASTs
In order to generate a =rtic_syntax::App= for recovery purposes =rtic_syntax::parse2= must be called directly with the arguments of =#[rtic::app(..)]= and with the input to the macro.
For example, in [[cref:lst:recovery-example]], =device = stm32f4::stm32f401= is the macro arguments, and =mod app { ... }= is the macro input.
Note the preamble on lines 1--3.
These must be skipped in order to parse correctly.
#+CAPTION: Example RTIC application declaration for execution on the STMicroelectronics STM32 NUCLEO-F401RE.
#+NAME: lst:recovery-example
#+begin_src rust
  #![no_main]
  #![no_std]

  #[rtic::app(device = stm32f4::stm32f401)] // tokens are skipped until this line is found
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[task(binds = SysTick)]
      fn task1(_: task1::Context) {
          // ...
      }

      #[task(binds = EXTI1)]
      fn task2(_: task2::Context) {
          // ...
      }
  } // this must be the last line of the file
#+end_src
# TODO document limitations of the parsing approach: no external tasks, no content after the macro

In order to isolate the =#[rtic::app(...)] mod app { ... }= section in [[cref:lst:recovery-example]] the ~std::String~ that represents the content of the source file must be converted to an [[acrfull:AST]];
or more specifically, a =proc_macro2::TokenStream2= [[parencite:&proc-macro2]].
This is done by help of the ~syn~ crate [[parencite:&syn]].

With a =TokenStream2= structure in hand [[glspl:token][tokens]] are skipped until the =proc_macro2::TokenTree::Group(_)= that contains =#[rtic::app(...)]= is found ([[cref:lst:recovery-example]], line 4).
The remainder of the source file is then assumed to be the =mod app { ... }= input to the =rtic::app= macro.

This places a few restrictions[fn:: The keywords *MUST* and *MUST NOT* shall be interpreted as described in [[textcite:&rfc2119]].] on how the RTIC application can be declared to be properly parsed:
1. tasks *MUST NOT* be externally declared;
2. the =rtic::app= macro *MUST* be called via =#[rtic::app]= (e.g. [[cref:lst:invalid-recovery-example]] will fail to parse); and
3. the =mod app { ... }= [[gls:token]] group terminator *MUST* be the last line of the source file ([[cref:lst:recovery-example]], line 27).
More restrictions that have yet to be discovered may apply.
#+NAME: lst:invalid-recovery-example
#+CAPTION: Valid RTIC application declaration that cannot be parsed by ~cargo rtic-scope trace~.
#+begin_src rust
  // ...
  use rtic::app;

  #[app(device = stm32f4::stm32f401)] // will not parse: #[rtic::app] must be used
  mod app {
      // ...
  }
#+end_src

# known and unknown maps
# TODO pluralize HardwareTask
At this point we have the necessary =rtic_syntax::App= structure to continue: =App::hardware_tasks= is a collection of =rtic_syntax::HardwareTask= that lists what interrupt handler each hardware task is bound to via the =binds= argument in =#[task(binds = ...)]=.
After parsing [[cref:lst:recovery-example]], =hardware_tasks= contains [fn:: Abstracted for brevity.]
#+begin_export latex
$$
\langle \text{\texttt{app::task1} binds to \texttt{SysTick}} \rangle,\quad\langle \text{\texttt{app::task2} binds to \texttt{EXTI1}} \rangle\text{.}
$$
#+end_export
Of these, the =app::task1= bind is considered /known/, and the =app::task2= bind is considered /unknown/.
A known bind is one that no more recovery work must be applied on.
This follows from [[cref:tbl:irqns]] in [[cref:theory:itm-proto]] which enumerates all numbers that can be in the packet's IRQ field:
All
#+begin_export latex
$$
\text{IRQn} < 16
$$
#+end_export
are common to all ARMv7-M targets, the name of which can be directly mapped to the RTIC task that binds the IRQ name.
All
#+begin_export latex
$$
\text{IRQn} \geq 16
$$
#+end_export
on the other hand, are not common to all ARMv7-M, and are thus platform-specific because the labels (specified via =#[task(binds = ...)]=) are unknown.
Additional recovery must be done to find these labels.

# PAC::Interrupt and known/unknown partitioning; Rust reflection woes
For any RTIC application, the labels are available in the =PAC::Interrupt= enum. For [[cref:lst:recovery-example]], =PAC= is =stm32::stm32f401=.
See [[cref:background:PAC]] for an example of such an enum.
By finding the label used in =#[task(bind = ...)]= in =PAC::Interrupt= we find what enum constructor to use.
With the enum in hand, we construct it and get the IRQ number offset $N$ via [[cref:lst:pac:extirq]].
#+NAME: lst:pac:extirq
#+CAPTION: Finding $N$ in [[cref:tbl:irqns]] for an external interrupt via the [[ACRshort:PAC]].
#+begin_src rust
  let label = PAC::Interrupt::EXTI1;
  assert_eq!(label.number(), 7);
#+end_src
To get the IRQ number of this unknown bind we simly sum it with $16$, as documented by [[cref:tbl:irqns]], via [[cref:lst:pac:irqsum]].
#+NAME: lst:pac:irqsum
#+CAPTION: Finding the IRQ number of an external interrupt by summing the offset documented by [[cref:tbl:irqns]].
#+begin_src rust
  let irq_nr = label.number() + 16;
  assert_eq!(irq_nr, 23);
#+end_src
This must be done for all unknown binds.

The above process is unfortunately non-trivial: Rust does not have dynamic programming features and an ideal evaluation function such as [[cref:lst:pac:ideal-pseudo]] is not realizeable.
#+NAME: lst:pac:ideal-pseudo
#+CAPTION: Non-realizeable pseudo code to dynamically resolve the IRQ number of an unknown bind via the [[ACRshort:PAC]]. ~quote~ is from [[textcite:&quote]].
#+begin_src rust
  use quote::quote;
  fn resolve_irq_nr(label: &str) -> u16 {
      quote!(PAC::Interrupt::$label).eval().number() + 16;
  }
#+end_src

# libadhoc
Enter =recovery::resolve_int_nrs=: given a list of labels, the function
1. extracts an embedded file tree constituting a skeleton crate to the RTIC application's ~target/cargo-rtic-trace-libadhoc~, by help of [[textcite:&includedir]];
2. writes the user-specified [[acrfull:PAC]] dependency into this crate's ~Cargo.toml~[fn:: By use of the ~pac_name~, ~pac_version~, ~pac_features~, and ~interrupt_path~ acquired from [[cref:impl:cargo-rtic-scope:read-manifest]].];
3. for each label: writes a non-mangled function with the same name as the label that returns the associated IRQ number offset, $N$ (for [[cref:lst:recovery-example]] the generated recovery code can be seen in [[cref:lst:resolve_int_nrs-example]]), to ~lib.rs~;
   #+NAME: lst:resolve_int_nrs-example
   #+CAPTION: Generated IRQ number recovery functions for [[cref:lst:recovery-example]] with ~interrupt_path = "st32::stm32f401::Interrupt"~ from the [[ACRshort:RTIC]] application's ~Cargo.toml~.
   #+begin_src rust
     use stm32::st32f401::Interrupt;

     #[no_mangle]
     pub extern fn EXTI1() -> u16 {
         Interrupt::EXTI0.number()
     }
   #+end_src
4. builds the crate as a [[gls:cdylib]];
5. loads the library into memory;
6. for each label: calls the associated function in the library to get the offset $N$ and sums it with 16; and
7. collects the results.
This collection then merges with the collection of known maps.

***** Generating the ~recovery::SoftwareMap~
:PROPERTIES:
:CUSTOM_ID: impl:software-map
:END:
The work to generate a =recovery::SoftwareMap= is similar to that of a =recovery::HardwareMap= in the sense that the RTIC application declaration must be parsed again (for a third, but last time).
This parsing pass is done via =SoftWareMap::parse_ast= instead of =rtic_syntax::parse2=.
As the function name implies the [[ACRshort:AST]] is parsed by skipping [[glspl:token][tokens]] until the =TokenTree::Group(_)= describing =#[trace]= is found.
When this [[gls:token]] is found the software task the macro is used on is associated with the current value of an internal counter for software task IDs.
This counter is modified in the same manner as the internal counter when =cortex_m_rtic_trace::trace= expands.

To complete the =SoftwareMap= the IDs of the [[ACRshort:DWT]] comparators and the interrupts which handle the dispatch of the application's software tasks must be recorded.
The former are acquired from  [[cref:impl:cargo-rtic-scope:read-manifest]] via the ~dwt_enter_id~ and ~dwt_exit_id~ fields.
The latter are acquired via =rtic_syntax::ast::AppArgs::extern_interrupts=.

For the example in [[cref:lst:rtic-scope:trace-software-task]], =SoftwareMap= would contain[fn:: Abstracted for brevity.] the information denoting =EXTI2= as the software task dispatcher and
#+begin_export latex
$$
\langle 0 \equiv \text{\texttt{app::task1}}\rangle,\quad\langle 1 \equiv \text{\texttt{app::task2}} \rangle\text{.}
$$
#+end_export
#+NAME: lst:rtic-scope:trace-software-task
#+CAPTION: RTIC application declaration with two traced software tasks: ~app::task1~ and ~app::task2~. ~EXTI2~ is declared as the software task dispatcher.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXTI2])]
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[trace] // task ID = 0
      #[task]
      fn task1(_: task1::Context) {
          // ...
      }

      #[trace] // task ID = 1
      #[task]
      fn task2(_: task2::Context) {
          // ...
      }
  }
#+end_src

The restrictions enumerated in [[cref:impl:hardware-map]] also apply when recovering information for traced software tasks.

The =trace= macro can also be applied on regular functions, effectively allowing the end-user to trace sections of both software and hardware tasks; see [[cref:impl:nested-tracing]] for an example.
Severe limitations apply when tracing functions inside tasks and are thus not useful in practise.
See [[cref:disc:nested-tracing-restrictions]] for more on this topic.
#+NAME: impl:nested-tracing
#+CAPTION: Tracing a function inside of a traced software example.
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401, dispatchers = [EXIT2])]
  mod app {
      // ...

      #[trace]
      #[task]
      fn task1(_: task1::Context) {
          // ...

          #[trace]
          fn nested() {
              // ...
          }
      }
  }
#+end_src
**** Spawning frontends
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:spawning-frontends
:END:
The host-side of RTIC Scope is diveded into two parts: the backend, ~cargo-rtic-scope~;
and the frontends, of which ~rtic-scope-frontend-dummy~ is provided within the scope of this thesis, fulfilling Requirement [[req:dummy]] and also acting as the frontend reference implementation (see [[cref:impl:rtic-scope-frontend-dummy]]).
Frontends are separate processes that receive JSON messages from the backend over a local socket connection (see [[cref:impl:api]]).
This section covers how frontends are specified, found in the environment, and executed.

The set of frontends to spawn is specified with the ~--frontend~ option before the ~<verb>~ in [[cref:lst:spawn-frontend]].
#+NAME: lst:spawn-frontend
#+CAPTION: Starting the RTIC Scope backend with an explicit frontend.
#+begin_src shell
  $ cargo rtic-scope --frontend=rtic-scope-frontend-dummy <verb> [OPTIONS...]
#+end_src
Multiple frontends (or multiple instances of a single frontend) can be spawned by specifying the ~--frontend~ option multiple times.
By default (by not specifying the option) a single instance of ~rtic-scope-frontend-dummy~ is spawned.

~cargo-rtic-scope~ searches for frontends in three locations in the environment.
With ~--frontend=rtic-scope-frontend-dummy~ the search pattern in decreasing order of priority is
1. in the ~PATH~ environmental variable;
2. the relative path: ~./rtic-scope-frontend-dummy~; and
3. the absolute path: ~/rtic-scope-frontend-dummy~.
If a higher priority location is valid, the search ends.
[[cref:lst:spawn-frontends]] contains an example of spawning three frontends in each of the supported location types.
#+NAME: lst:spawn-frontends
#+CAPTION: Starting the RTIC Scope backend with three explicit frontends: one in ~PATH~, one relative, and one absolute.
#+begin_src shell
  $ cargo rtic-scope --frontend=frontend-in-PATH \
                     --frontend=./path/to/relative/frontend \
                     --frontend=/path/to/absolute/frontend \
                     <verb> [OPTIONS...]
#+end_src

As of RTIC Scope v0.3.0, a frontend takes zero arguments and *MUST* return a path to a Unix socket on =stdout= which the backend can use to communicate with the frontend.
**** Sourcing the trace stream from the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reading-the-trace-stream
:END:
# Introduce the two main sources
At this point a line of communication with the target must be established.
Internally, this line of communication is known as a /source/ of which only one is established before =cargo-rtic-scope= traces the target.
As of v0.3.0 two sources are implemented:
- a TTY/serial source :: which configures and reads the trace data from a serial device; and
- a probe source :: wherein =probe-rs= is used to read trace data from supported targets.

A serial source is used if =--serial= is specified to the =trace= verb.
When a serial source is used =cargo-rtic-scope= must know what baud rate to configure the device for.
This is specified via the =tpiu_baud= field in the crate manifest (see [[cref:lst:cargo-rtic-scope:manifest-metadata-example]]) but can also be overridden via the =--tpiu-baud= option.
See [[cref:lst:tty-source]] for an example of these options.
#+NAME: lst:tty-source
#+CAPTION: Tracing a target by reading the trace stream from a serial device at ~/dev/ttyUSB3~ at 115200 bauds.
#+begin_src shell
  $ cargo rtic-scope trace --serial /dev/ttyUSB3 --tpiu-baud 115200 [OPTIONS...]
#+end_src

A probe source is used if =--serial= is not specified.
=cargo-rtic-scope= will then use the first probe it can find on the system.
If multiple probes are attached =--probe VID:PID[:Serial]= can be used to specify one.
A list of connected and supported probes can be queried by specifying the =--list-probes= flag.

When the target is traced in [[cref:impl:cargo-rtic-scope:trace-target]] the trace stream is simply read from the serial device if one is used.
If a probe source is used =probe-rs= sends the appropriate commands to the used probe polling for available trace data.
**** Flashing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flash-target
:END:
If the target under trace is supported by =probe-rs= it can optionally be flashed before tracing begins.
This is the default behavior in order to simplify an iterative development process but can be disabled by specifying the =--dont-touch-target= flag to the =trace= verb.
If a chip is supported =cargo-rtic-trace= must know its memory layout for flashing.
This is done via the =--chip= option.
See the example in [[cref:lst:chip-opt-example]].
#+NAME: lst:chip-opt-example
#+CAPTION: Flashing and tracing an STMicroelectronics STM32 NUCLEO-F401RE.
#+begin_src shell
  $ cargo rtic-scope trace --chip stm32f401ret [OPTIONS...]
#+end_src

The list of chips that =probe-rs= supports can be queried by specifying the =--list-chips= to the =trace= verb.

**** Flushing trace metadata to file
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:flush-metadata
:END:
The penultimate step before tracing begins is flushing all metadata related to the trace to the replay file created in [[cref:impl:cargo-rtic-scope:create-trace-file]].
The metadata is contained in a =recovery::TraceMetadata= structure, listed and described in [[cref:lst:TraceMetaData]].
Of these fields
- =maps: TraceLookupMaps= :: is described in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]];
- =reset_timestamp= :: is an approximate reset timestamp (the target is actually reset after this structure has been flushed to file, in [[cref:impl:cargo-rtic-scope:reset-target]]); and
- =comment= :: is an optional comment describing the trace which is supplied via the =--comment= option to the =trace= verb.
The data that is flushed to file is a JSON-representation of the structure, serialized by help of =serde_json= as implied by the derivation of the =Serialize= and =Deserialize= traits [[parencite:&serde-json]].
#+NAME: lst:TraceMetaData
#+CAPTION: ~recovery~ structure containing all metadata related to a trace.
#+begin_src rust
  /// Contains all metadata for a single trace.
  #[derive(Clone, Serialize, Deserialize)]
  pub struct TraceMetadata {
      /// Name of the RTIC application that was/is traced.
      pub program_name: String,

      /// Lookup maps for data received over ITM to RTIC application idents.
      maps: TraceLookupMaps,

      /// Timestamp of target reset, after which tracing begins.
      ///
      /// Note: this timestamp is sampled host-side and is approximate.
      reset_timestamp: chrono::DateTime<Local>,

      /// Frequency of the target TPIU clock. Used to generate absolute
      /// timestamps. Set via `tpiu_freq` in
      /// `[{package,workspace}.metadata.rtic-scope]` from `Cargo.toml` or
      /// overridden via the `--tpiu-freq` trace option.
      tpiu_freq: u32,

      /// Optional comment of this particular trace.
      pub comment: Option<String>,
  }
#+end_src

This structure is later read back for trace replay in [[cref:impl:cargo-rtic-scope:replay]].
**** Resetting the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:reset-target
:END:
The last step before tracing the target is optionally resetting it.
This is the default behavior but can be disabled by specifying the =--dont-touch-target=.
Resetting the target causes it to begin executing the flashed application from the beginning.
If =--dont-touch-target= was not specified the executing application will be the specified RTIC application.

From this point on the target will generate and emit ITM packets.

**** Tracing the target
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:trace-target
:END:
With all the preparatory steps concluded and the target being (optionally) reset its up to =cargo-rtic-scope= to record these packets host-side.
This is done in a number of steps in the imaginatively named =run_loop= function:
1. A SIGINT handler is installed, which allows the end-user to terminate =cargo-rtic-scope=.
   If this signal is not eventually sent ~cargo-rtic-scope~ will never termiate.
2. A second thread is spawned with the mission of polling trace data from the source.
   In order to avoid the generation of overflow packets the should poll data as fast as possible.
   The easiest implementation to accomplish this is via a separate thread.
3. In a loop:
   1. Asynchronously polls any buffered trace data from the separate thread and the eventual SIGINT signal for a duration of 100ms.
      If trace data has been read, forward this to the aply named =handle_packet= function (see below).
      If SIGINT is received the loop breaks and =cargo-rtic-trace= terminates.
      If after 100ms nothing happens:
   2. a message from the spawned frontends is read (if any) and echoed as an error;
   3. a message of the tracing status is echoed.
      This status message describes:
      - the application under trace;
      - how many ITM packets that have been recorded;
      - how many of these packets that are malformed or unmappable;
      - for how long the application has been traced;
      - how many ITM packets per second that are being recorded; and
      - how many sinks that are operational (not marked as broken; see below).

=handle_packet= does just that: handles a single =TimestampedTracePacket= (henceforth referred to as a /packet chunk/).
This is done several steps:
1. first, the packet chunk is converted to an =api::EventChunk= (see [[cref:impl:api]]) via =TraceMetadata::build_event_chunk= (see below).
2. Any unmappable, unknown, or invalid packets ITM packets in the chunk are echoed as warnings to the end-user with an apt message.
3. Chunks are /drained/ to all /sinks/ (the replay file and all spawned frontends).
   If a drain fails for any sink, it is marked as broken and an error is echoed to the end-user.
   As long as at least one sink is not marked as broken, tracing continues.[fn:: TODO tracing should stop if we cannot drain to file.]
   If all sinks are marked as broken =cargo-rtic-scope= terminates with an error.

=TraceMetadata::build_event_chunk= is responsible for recovering RTIC application metadata for a packet chunk.
This is done by matching all =itm::TracePacket= structures in the chunk: If a packet in the chunk is
- a synchronization packet (=TracePacket::Sync=), it is ignored because it does not contain any trace information;
- an exception trace packet (=TracePacket::ExceptionTrace=), the lookup maps generated in [[cref:impl:cargo-rtic-scope:generating-metadata-maps]] are consulted for the task matching the packet's IRQ number.
  If the exception trace corresponds to a hardware task, an =api::EventType::Task= is constructed.
  If the trace corresponds to a software task dispatcher or a Thread mode enter/exit it is ignored because it contains redundant trace information.[fn:exception-number-0]
  If none of these predicates are true the trace is logged as an /unmappable event/ by the construction of an =api::EventType::Unmappable=.
- If the chunk packet is a data trace value (=TracePacket::DataTraceValue=), the lookup maps are again consulted:
  if the comparator ID in the packet matches either =dwt_enter_id= or =dwt_exit_id= then the trace is a software task event.
  The packet's data value is matched against the set of RTIC application tasks decorated with =#[trace]=.
  If such a match exists, an =api::EventType::Task= is constructed, otherwise the trace is logged as an unmappable event.
If none of the above predicates were true, the chunk packet is logged as an /unknown packet/ by wrapping it in an =api::EventType::Unknown=.
Last of all are the /malformed packets/: these are simply wrapped in an =api::EventType::Invalid=.

*** Decoding the ITM packet stream via ~itm~
:PROPERTIES:
:CUSTOM_ID: impl:itm
:END:
The =itm= library crate, [[textcite:&itm]], is
#+ATTR_LATEX: :environment quotation
#+begin_quote
\noindent
A decoder for the [[ACRshort:ITM]] and [[ACRshort:DWT]] packet protocol[fn:: [[ACRshort:DWT]] packets (hardware event packets) are included in the [[ACRshort:ITM]] packet protocol standard.] as specifed in [[[textcite:&arm-rm Appendix D4]]].

Aside from covering the entirety of the protocol, this crate offers two iterators which reads data from the given [\textttBreak{std::io::Read}] instance:
- [\texttt{iter::Singles}] :: which decodes each packet in the stream in sequence, yielding [\textttBreak{TracePacket} structures].
- [\texttt{iter::Timestamps}] :: which continuously decodes packets from the stream until a local timestamp is encountered,
  yielding \linebreak[4] [\texttt{TimestampedTracePackets} structures],
  which contains a \linebreak[4] [nanosecond-accurate] timestamp relative to target reset of when the packets where generated target-side.[fn:: TODO not necessarily true, right?]
#+end_quote

While the implementation of =itm= has been influenced by the development of RTIC Scope it is logically disjoint from the the RTIC Scope feature set.
=itm= can thus be considered a wholly separate project but its inception was a precursor to RTIC Scope in order to fulfill Requirement [[req:decode]], and it is thus within the scope of this thesis.
RTIC Scope is then considered a /downstream/ crate of =itm=, because it depends on it.

The crate is a /green-field implementation/ of its deprecated v0.3 release branch, [[textcite:&itm-old]], of which this v0.7 (and above) release branch is only trivially influenced[fn:: Namely the implementation of the =std::io::Read= trait.].
Another =itm=-downstream crate is =itm-decode= [[parencite:&itm]] which aims to eventually replace the also deprecated =itm-tools= [[parencite:&itm-tools]], but that task is outside the scope if this thesis (see [[cref:fut:itm-tools]]).
Both =itm-decode= and =itm-tools= are convenient UNIX-like tools for decoding the ITM packet protocol.

=itm= is a packet decoder with state that handles its own data input.
After constructing a new decoder via =itm::Decoder::new= with an implementation of =std::io::Read= ---
e.g. a =std::fs::File= pointing to a preconfigured serial device, or a =probe_rs::architecture::arm::swo::SwoReader= ---
decoded packets are trivially acquired via the exposed iterators summarized above.
RTIC Scope utilizes the =iter::Timestamps= iterator, and is thus the only iterator covered in this text.

As covered in [[cref:theory:itm-proto]], the [[ACRshort:ITM]] packet protocol define packets that contain a one-byte /header/, which describes what type of data a certain packet contains; how long the packet /payload/ is, a byte multiple; and the packet payload.
Effectively, the protocol follows a [[acrfull:TLV]] encoding sheme.
Decoding such a protocol is rather trivial, especially in Rust:
the individual bytes of the header are pattern-matched in order to decode the packet type after which the remaining bytes are dispatched to another pattern-matcher in order to decode its payload.
On success an =itm::TracePacket= is emitted.
On failure --- if a header or payload contains data that is not covered by [[textcite:&arm-rm Appendix D4]] --- an =itm::MalformedPacket= is emitted, describing why the decode failed.

=iter::Timestamps= intercepts all global and local timestamps in order to maintain a monotonically increasing duration from target boot.
Logically, this duration is initially zero, before any timestamp packets have been decoded.
When a local timestamp is intercepted, its value is added to the current duration and its quality recorded.
When a global timestamp is intercepted, the duration is reset to this value, discarding information from previously received timestamps.

Any non-timestamp packets will be buffered until a local timestamp is intercepted after which they will be associated to this latest timestamp in an emitted =TimestampedTracePackets=.
This structure also contains a field describing how many [[ACRshort:ITM]] packets were consumed to generate it.
This information is used in =cargo-rtic-scope= in order to report the number of trace packets received per second.

# XXX qualitative/quantitive? Am I formulating correctly here?
The maintained and emitted durations are structures with a qualitative unit that which the timestamp packets themselves does not contain; timestamp packets contain a unit-less counter, which is quantitative.
In order to calculate a duration two pieces of information must be known:
- the frequency of the [[ACRshort:TPIU]] reference clock; and
- the prescaler of this clock.
This information is the same that is configured in [[cref:impl:rtic-trace]].
When a full timestamp has been received the offset to add to the current duration is calculated via =iter::calc_offset= seen in [[cref:lst:calc-offset]].

#+NAME: lst:calc-offset
#+CAPTION: Calculation of the offset to add to the current timestamp.
#+begin_src rust
  fn calc_offset(ts: u64, prescaler: Option<LocalTimestampOptions>, freq: u32) -> Duration {
    let prescale = match prescaler {
        None | Some(LocalTimestampOptions::Enabled) => 1,
        Some(LocalTimestampOptions::EnabledDiv4) => 4,
        Some(LocalTimestampOptions::EnabledDiv16) => 16,
        Some(LocalTimestampOptions::EnabledDiv64) => 64,
        Some(LocalTimestampOptions::Disabled) => unreachable!(), // checked in `Timestamps::new`
    };
    let ticks = ts * prescale;
    let seconds = ticks as f64 / freq as f64;

    // NOTE(ceil) we rount up so as to not report an event before it
    // occurs on hardware.
    Duration::from_nanos((seconds * 1e9).ceil() as u64)
}
#+end_src

The generation of local timestamps is critical in order to ensure a qualitative trace.
If trace packets are generated faster than they can be emitted from the target, a queued packet is dropped in favor of an overflow packet.
One of these packets may be a local timestamp.
For a discussion on how to avoid overflows, see [[cref:disc:overflows]].

For a discussion on how to increase the quality of timestamps (and thus the general quality of the trace), see [[cref:disc:ts-quality]].

*** Associating trace packets with RTIC task events
# TODO build_event_chunk

*** Forwarding resolved trace stream to sinks via ~rtic-scope-api~
:PROPERTIES:
:CUSTOM_ID: impl:api
:END:

*** Handling the resolved trace stream in the frontend
:PROPERTIES:
:CUSTOM_ID: impl:rtic-scope-frontend-dummy
:END:
# TODO we need some sentence before we start talking about the dummy.
The purpose of the of =rtic-scope-frontend-dummy= frontend is to act as a reference implementation upon which more useful frontends can be built.
These is no limit to what a frontend could do.
It could present a real-time graphical representation of the system alike a logic analyzer, it could store the resolved trace in a database, or it could simply echo the messages to =stderr=.

The dummy frontend is trivial in implementation: [[cref:lst:dummy-src]] contains its entirety with exhaustively descriptive comments.
#+NAME: lst:dummy-src
#+CAPTION: The full source code of the dummy frontend.
#+begin_src rust
  #![allow(rustdoc::bare_urls)]
  //! Reference frontend implementation for RTIC Scope.
  #![doc = include_str!("../../docs/profile/README.md")]

  use anyhow::{Context, Result};
  use rtic_scope_api as api;
  use serde_json::Deserializer;

  fn main() -> Result<()> {
      // Create frontend socket in a temporary directory, print it for the parent backend.
      let socket_dir = tempfile::TempDir::new()
          .context("Failed to create temporary directory for frontend socket")?;
      let socket_path = socket_dir.path().join("rtic-scope-frontend.socket");
      let listener = std::os::unix::net::UnixListener::bind(&socket_path)
          .context("Failed to bind frontend socket")?;
      println!("{}", socket_path.display());

      // Deserialize api::EventChunks from socket and print events to
      // stderr along with nanoseconds timestamp.
      let (socket, _addr) = listener.accept().context("Failed to accept()")?;
      let stream = Deserializer::from_reader(socket).into_iter::<api::EventChunk>();
      let mut prev_nanos = 0;
      for chunk in stream {
          let chunk = chunk.context("Failed to deserialize chunk")?;
          let nanos = chunk.timestamp.offset.as_nanos();
          let diff = nanos - prev_nanos;
          eprintln!("@{} Âµs (+{} ns): {:?}", nanos, diff, chunk.events);
          prev_nanos = nanos;
      }

      Ok(())
  }
#+end_src

*** Replaying a trace
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope:replay
:END:
Replaying a trace is done via the =replay= verb.
The implementation behind replaying a trace is the same as recording one, only that the source is a replay file instead of a serial device or a probe.
A replay file can be specified in two ways: by use of an index of which the =--list= flag lists the indices; or by specifying the path to the trace file.
[[cref:lst:replay-examples]] exemplifies these two methods.
When using an index to replay a file the default directory within which to search for replay files can be overridden via =--trace-dir=.

#+NAME: lst:replay-examples
#+CAPTION: Example commands of listing and replaying recoded traces.
#+begin_src shell
  # listing available replay files
  $ cargo rtic-scope replay --list
  0       target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
  # replaying the trace with index 0
  $ cargo rtic-scope replay 0
  # specifying the path to the replay file
  $ cargo rtic-scope replay --trace-file target/rtic-traces/atsamd-demo-g472bc3d-dirty-2022-01-19T17:05:21.trace
#+end_src

** Results
*** Using RTIC Scope
From an end-user perspective RTIC Scope offers a "batteries-included" toolset that enables great insight into a target RTIC applications,
provided that a small set of limitations are adhered to and specific metadata is added to the application crate in question.
To install RTIC Scope, an end-user executes
#+begin_src shell
  $ cargo install cargo-rtic-scope
  $ cargo install rtic-scope-frontend-dummy
#+end_src
and adds the following metadata to their RTIC application's ~Cargo.toml~:
#+begin_src toml
  [package.metadata.rtic-scope]
  # necessary information for RTIC metadata recovery
  pac_name = "stm32f4"
  pac_features = ["stm32f401"]
  pac_version = "0.13"
  interrupt_path = "stm32f4::stm32f401::Interrupt"

  # ITM/DWT/TPIU parameters
  tpiu_freq = 16000000
  tpiu_baud = 115200
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1

  # Whether it is expected that the target generates packets that do not adhere to the ITM standard.
  # For debugging purposes.
  expect_malformed = true
#+end_src

# TODO document cortex-m-rtic-trace usage
**** Tracing the ~atsame51n~
**** Tracing the ~stm32f401retx~

** Discussion
:PROPERTIES:
:CUSTOM_ID: discussion
:END:
*** What project does ~itm~ belong to?
:PROPERTIES:
:CUSTOM_ID: disc:itm-embedded-wg
:END:
# TODO discuss on where the final itm actually belongs. Link to the RFC discussion.
*** Tracing overhead with RTIC Scope
:PROPERTIES:
:CUSTOM_ID: disc:perf
:END:
[[parencite:&arm-cortex-learn 24]] states:
#+begin_quote
Except for the power that is consumed by the system trace components,
trace is almost entirely non-invasive. This means that performing trace
generation and collection does not influence the wider system.
#+end_quote

The target-side code of RTIC Scope itself has a negligible performance impact during execution:
- the ITM/DWT/TPIU units need only be configured once in =#[init]= or during some other preparatory stage; and
- when software tasks are traced, a =u8= variable write must be done when entering and exiting the task.

The performance of the host-side =cargo-rtic-scope= and =rtic-scope-frontend-dummy= have not been measured.

# TODO DWT unit consumption, 2x u32-aligned .data usage
# TODO add a listing of the watch variable structs to detail alignment.
*** Restrictions of tracing functions inside tasks
:PROPERTIES:
:CUSTOM_ID: disc:nested-tracing-restrictions
:END:
*** Should ~cargo-rtic-scope~ terminate on malformed packets?
# TODO also related: MalformedPacket in itm
*** FIFO queues
# TODO go over all the FIFO queues in the system. How many do we have? which are limited in space?
*** Avoiding overflows
:PROPERTIES:
:CUSTOM_ID: disc:overflows
:END:
# XXX merge fifo queues into this section?
Summarized: the target must not generate packets faster than it can emit.
To avoid timestamps, in order of recommentation:
- increase the baud rate (host-side limits (Linux vs. BSD, may apply));
- increase the TPIU clock frequency; and
- lower system clock.

# refer to ETB here, with which we get another set of issues: host-side poll-rate, etc.
*** Increasing timestamp quality
:PROPERTIES:
:CUSTOM_ID: disc:ts-quality
:END:
# TODO find what I had to do in order to increase more local timestamps inbetween DWT packets. Show itm-decode output examples.
*** Lessons learned
Why the thesis took to long, etc.
*** Future work
# Link to all(?) issues

# TODO deprecating cortex-m-rtic-trace: push upstream to RTIC, probe-rs
# TODO cargo-embed functionality, RTICScope.toml
# TODO queries from frontend
# TODO replace serde with protobuf
# TODO HIL testing?
# TODO replace bash scripts with xtask testing
# TODO Cargo warning/errors not propagated when building application
# TODO Cargo-flash hints?

# TODO add a link to the issue tracker, or should we list all issues that are open when v0.3.0 is tagged?
**** Local timestamp prescaler configuration
:PROPERTIES:
:CUSTOM_ID: fut:swoscaler
:END:
# TODO integer division
**** Trace stream ID configuration
:PROPERTIES:
:CUSTOM_ID: fut:TraceBusID
:END:
# TODO 0 may not be a valid value, and tracebusid should be set before ITMENA
**** [[ACRshort:DWT]] comparator configuration
:PROPERTIES:
:CUSTOM_ID: fut:dwtcomps
:END:
# TODO move positional arguments to the struct instead. ensure that the two comparators are not the same one.
**** Optimizing [[ACRshort:DWT]] comparator utilization
:PROPERTIES:
:CUSTOM_ID: fut:opt-dwt-units
:END:
It would then be logical to store both =u8= variables on the same 32-bit address base: the first at offset 0, the other at offset 1.

# TODO elaborate
**** Deprecating ~cortex-m-rtic-trace~
:PROPERTIES:
:CUSTOM_ID: fut:rm-rtic-trace
:END:
# TODO merging things upstream into probe-rs, RTIC, etc.
# target-side conf can be done by RTIC
**** Supporting other [[ACRshortpl:RTOS]] than [[ACRshort:RTIC]]
**** Publishing all crates to the crate registery
**** Replacing ~itm-tools~
:PROPERTIES:
:CUSTOM_ID: fut:itm-tools
:END:

** Conclusion
** Glossary & Bibliography                                          :ignore:
[[printglossaries:]]
[[printbibliography:]]
** Appendices                                                       :ignore:
#+begin_export latex
\appendix
\addappheadtotoc
#+end_export
*** TODO Application to a complex control system
:PROPERTIES:
:CUSTOM_ID: control-application
:END:
 # The results of the R7014E-alike course



* Footnotes

[fn:exception-number-0] During experimentation packets with a zero in this field were encountered. [[textcite:&arm-rm B1.3.1]] notes that a /Thread mode/ is entered on target reset.  [[ACRshort:RTIC]] executes its task by help of exceptions which warrant an enter into a /Handler mode/. [[textcite:&arm-rm B1-517]] the comments that a value of [[Acrfull:IPSR]] is zero is no exception handler is executing. These Thread mode changes were always observed before and after non-preempted [[ACRshort:RTIC]] tasks entered and exited.


[fn:recovery-build] A positive side-effect of this step is that the RTIC Scope user does not have to manually call =cargo build= before =cargo rtic-scope trace=.

[fn:2] Additional tasks aside from regulation could for example include handling firmware updates over the air and switching mode of operation on a button press.
[fn:1] The program that executes on the embedded system when initialization has concluded. In some contexts also referred to as the "main loop".

[fn:dwt-running-bit] Alternatively, one bit in the =DataTraceValue= payload can denote whether a task was entered or exited.

[fn:cargo] See https://crates.io/crates/cargo.

[fn:rtic-syntax] See https://crates.io/crates/rtic-syntax.

[fn:decoder] Based upon the existing works of ~itm-tools~[fn:itm-tools].

[fn:memory-lanes] https://github.com/rtic-rs/rfcs/issues/31 discusses the RTIC-abstraction of RTT and similar peripherals to "memory lanes".

[fn:itm-tools] See https://github.com/japaric/itm-tools.

[fn:cli] Command-line interface.

[fn:dwt-n] $n$ emphasized for reasons of readability and typesetting.
