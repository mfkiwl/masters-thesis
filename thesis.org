# -*- eval: (org-indent-mode +1) -*-
# -*- eval: (visual-line-mode +1) -*-

#+TITLE: RTIC Scope â€” Real-Time Tracing Support for the RTIC RTOS Framework
#+AUTHOR: Viktor Vilhelm Sonesten
#+EMAIL: vikson-6@student.ltu.se
#+LANGUAGE: en
#+OPTIONS: ':t toc:nil title:nil todo:nil

#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: thesis
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+latex_header: \usepackage{kpfonts}[maths]
#+latex_header: \usepackage{libertine}
#+latex_header: \usepackage{inconsolata}
#+latex_header: \usepackage[style=apa,hyperref=true,url=true,backend=biber]{biblatex}
#+latex_header: \addbibresource{./ref.bib}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{newfloat}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{frame=lines,breaklines,breakafter=/.,fontsize=\footnotesize,linenos}
#+LATEX_HEADER: \usepackage[inline]{enumitem}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor={red!50!black},citecolor=blue,breaklinks=true}
#+LATEX_HEADER: \usepackage{glossaries}
#+latex_header: \usepackage{microtype}
#+latex_header: \usepackage{tocbibind}
#+latex_header: \usepackage{todonotes}
#+latex_header: \usepackage[capitalize]{cleveref}
#+LATEX_HEADER: \makeglossaries

#+NAME: glossary
| label       | name            | description |
|-------------+-----------------+-------------|
| tokenstream | tokenstream     | cock        |
| token       | token           | TODO        |
| AST         | AST             | AST         |
| static-anal | static analysis | TODO        |
| sample-rate | sample rate     | TODO        |
| downstream  | downstream      | TODO        |
| frontend    | frontend        | TODO        |
| upstream    | upstream        | TODO        |
| elf:data    | \texttt{.data}  | TODO        |

# XXX some of these should link to the glossary
#+NAME: acronyms
| key           | abbreviation                 | full form                                             |
|---------------+------------------------------+-------------------------------------------------------|
| PC            | PC                           | \textit{program counter}                              |
| CPU           | CPU                          | \textit{central processing unit}                      |
| RTIC          | RTIC                         | \textit{Real-Time Interrupt-driven Concurrency}       |
| RTOS          | RTOS                         | \textit{real-time operating system}                   |
| SRP           | SRP                          | \textit{Stack Resource Policy}                        |
| DCB           | DCB                          | \textit{Debug Control Block}                          |
| SCS           | SCS                          | \textit{System Control Space}                         |
| SCB           | SCB                          | \textit{System Control Block}                         |
| DCB_DEMCR     | DEMCR                        | \textit{Debug Exception and Monitor Control Register} |
| ITM           | ITM                          | \textit{Instrumentation Trace Macrocell}              |
| TPIU          | TPIU                         | \textit{Trace Port Interface Unit}                    |
| DWT           | DWT                          | \textit{Data Watchpoint and Trace}                    |
| ETB           | ETB                          | \textit{Embedded Trace Buffer}                        |
| WCET          | WCET                         | \textit{Worst Case Execution Time}                    |
| EDF           | EDF                          | \textit{Earliest Deadline First}                      |
| PAC           | PAC                          | \textit{Peripheral Access Crates}                     |
| API           | API                          | \textit{Application Programming Interface}            |
| TPIU_ACPR     | TPIU\textunderscore ACPR     | Asynchronous Clock Prescaler Register                 |
| ETM           | ETM                          | \textit{Embedded Trace Macrocell}                     |
| DWT_CTRL      | DWT\textunderscore CTRL      | \textit{Control Register}                             |
| TPIU_TYPE     | TPIU\textunderscore TYPE     | \textit{TPIU Type Register}                           |
| ITM_TCR       | TPIU\textunderscore TCR      | \textit{Trace Control Register}                       |
| RAZ-WI        | RAZ/WI                       | \textit{Read-As-Zero, Writes Ignored}                 |
| RAZ           | RAZ                          | \textit{Read-As-Zero}                                 |
| RAO           | RAO                          | \textit{Read-As-One}                                  |
| DWT_FUNCTIONn | DWT\textunderscore FUNCTION$n$ | \textit{Comparator Function registers}                |
| SBZ           | SBZ                          | \textit{Should-Be-Zero}                               |
| DWT_COMPn     | DWT\textunderscore COMP$n$   | \textit{Comparator registers}                         |
| DWT_MASKn     | DWT\textunderscore MASK$n$   | \textit{Comparator Mask registers}                    |

# TODO install and apply a grammar checker.
# TODO use glossary everywhere <https://www.overleaf.com/learn/latex/Glossaries>
# TODO +NAME all listings?
# TODO cite any mentioned crates.
# TODO call an RTIC app just that, or firmware, throughout.
# TODO fix cites to sections (remove the "p."?)

* Org setup                                                        :noexport:
  #+begin_src emacs-lisp :result output :session :exports both
    ;; ignore some headlines
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines))

    ;; minted code listings
    (require 'ox-latex)
    (setq org-latex-listings 'minted)

    ;; use the book class, but without any \parts
    (add-to-list 'org-latex-classes
                 '("thesis"
                   "\\documentclass{memoir}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    ;; use \cref instead of \ref, for cleveref
    (setq org-ref-default-ref-type "cref")

    (setq org-latex-prefer-user-labels t)
  #+end_src
#+RESULTS:

* Frontmatter                                                        :ignore:
#+LATEX: \frontmatter
# Make this a single paragraph; use unambiguous terms; aim for 250 words; 3-5 keywords.
#+begin_abstract
Here be an abstract...
#+end_abstract
#+begin_export latex
\newlist{inline-enum}{enumerate*}{1}
\setlist[inline-enum]{label=(\roman*)}

% Include "List of Listings" in the TOC
\renewcommand{\listoflistings}{
  \cleardoublepage
  \addcontentsline{toc}{chapter}{\listoflistingscaption}
  \listof{listing}{\listoflistingscaption}
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\listoftodos
\tableofcontents
\newpage
\listoftables
\newpage
\listoffigures
\newpage
\listoflistings
\newpage

% Start counting with arabic numbers
\mainmatter

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Fix todonotes behavior
\setlength{\marginparwidth}{2cm}
\reversemarginpar
#+end_export

* *The Paper*                                                        :ignore:
** Introduction
# What are embedded systems, regulators, and how do they relate?
Embedded systems --- a unit combination of a central processing unit, system memory, and input/output peripheral devices --- serve a key role in the operation of systems with electronical components where computations must be made.
A prime examples of such systems are digital control systems which regulate one or more control quantities such that they adhere to designed characteristics.
Often the goal is to track a reference signal; such a control system is known as a regulator.
A regulator observes (either directly or by approximation) the internal states of a system under control via sensors and affect the system via actuators.
For example, one may wish to keep a rocket on a set path to reach orbit, or control the internals of a nuclear power plant to maximize electrical power output while keeping the plant within safe operation boundaries.

# On the real-time restrictions of control systems; exponential complexity phenomena.
A key design parameter of digital controllers is the [[gls:sample-rate][sample rate]]: if too low or unconsistent, the controlled system will end up unstable [[parencite:&franklin]].
The rocket may thus fly off course, or the nuclear reactor reach a meltdown.
This puts a real-time constrain on the digital controller which greatly limits how it can be implemented.
Further, a digital controller under implementation must be debugged so that the engineers can verify its correct operation and realize the real-time constrain.
This task grows exponentially in difficulty with as the number of system states, inputs, and outputs increase.
A similar phenomena is observed for embedded systems with an increasing number of tasks.[fn:2]

# The observer effect; data exfiltration.
Unfortunately are embedded systems subject to the observer effect: to observe the internal state of a embedded system (i.e., system variables in memory) its operation must be affected.
# A proper implementation would not block on a serial write.
This observeration is often realized by exfiltrating data via serial communication which in the best case can induce bus contention and full output queues,
but it is not uncommon that a program blocks until the data has been serialized, severely affecting the regulation if the payload is large.
In a perfect implementation, the user application[fn:1] would only concern itself with its mainsake regulation procedure and leave data exfiltration to a completely disjoint system, removing the observer effect and thus the effect on the underlying control system.

# ARM, tracing subsystem and possible exploitation.
ARM is an ubiquitous vendor for embedded systems with a number of sub-vendors (e.g. STMicroelectrics, NXP Semiconductors, Nordic Semiconductors).
The ARMv7-M platform standard offers debugging facilities that enables the developer to trace the system.
From [[textcite:&arm-cortex-learn]]: "Trace refers to the process of capturing data that illustrates how the components in a design are operating, executing, and performing".
Additionally, "[Trace generation is] almost entirely non-invasive. [Trace generation] does not influence the wider system".
These trace facilities allows for an event-based monitoring of
- interrupt handler enters and exits (tracing of hardware-bound tasks);
- Read and write access to in-memory address spaces (system state variables, software tasks); and
- [[acrfull:PC]] samples, among other features.
The generated trace is then exfiltrated via asynchronous serial using a packet protocol (described in [[#debug-periphs]]), henceforth referred to as the "trace stream".
These facilities are not disjoint (if they were, no insight into the system could be offered) but because the generation of the trace stream does not influence the wider system (as per [[citeauthor:&arm-cortex-learn]]) the trace stream (with system-external collection) is a suitable candidate for exploitation to realize insight into a control system with minimal observer effect.

# Less work, more sleep.
Further, with non-invasive trace generation, less code must be executed by the [[acrfull:CPU]], allowing a shorter duty-cycle of the user application.
With a decreased duty-cycle, the system can be put to sleep longer, and thus conserve energy.

# On real-time implementation restictions, embedded implementation difficulties in general. Enter RTIC.
The development of embedded system in general is a difficult one.
In comparison to general-purpose computers, where one often need not worry about resource limitations, embedded systems are constrained in all manners such that costs can be minimized for their non-general applications.
# No rich OS; no two embedded platforms are the same.
An embedded developer seldom have access to a rich operating systems --- a Linux-based distibution, for example --- which offers general-purpose facilities based on dynamic allocations and a common environment to simplify implementation.
Embedded platforms usually differ significantly, and porting an implementation to another platform is no small task.
This compares to general-purpose computers where a program written on one computer can be executed on another one, as long as the operating environment remains the same.
# Side effects and priority inversions.
Embedded platforms are much more subject to side-effects where peripherals are operated by writing data to memory-mapped registers.
Of certain importance is the problem of priority inversions, where a task of lower priority executes instead of a higher prioritized task because of implementation error.
In summary it is easy to put an embedded system in an incorrect or unknown state.
# Enter RTIC.
In order to lighten the implementation burden one may employ [[Acrfull:RTIC]] (see [[#rtic]]), [[textcite:&rtic]]: a [[Acrfull:RTOS]] developed at LuleÃ¥ Technical University based on the extensively studied [[Acrfull:SRP]], which
- prevents deadlocks;
- mitigates priority inversions; and
- is compatible with [[Acrfull:EDF]] sheduling [[parencite:&srp]].
RTIC thus removes some burden out-of-the-box while also
- implementing message passing between tasks;
- incurring a minimal scheduling overhead;
- being highly efficient on memory usage; and
- being amenable to [[Acrfull:WCET]] analysis [[parencite:&rauk]].

# Oh yeah, and Rust
RTIC is written in Rust which removes additional developer overhead (see [[#rust]]).

# Project aim
The aim of this thesis is thus to employ and extend upon RTIC with a toolset, aptly named RTIC Scope, to leverage [[Citeauthor:&arm-cortex-learn][ARM]]'s non-intrusive tracing facilites while requiring minimal overhead for the end-user developer to apply the toolset, greatly lightening the burden when implementing a digital control systems.
The resulting toolset will be employed to implement a regulator for a non-trivial dynamic system (see [[#control-application]]), and the functionality and ergonomics of the toolset evaluated (see [[#discussion]]).

*** Background
This introductory section covers the software components that have realized RTIC Scope.

**** The Rust programming language
:PROPERTIES:
:CUSTOM_ID: rust
:END:
Rust is a system programming language that guarantees the absence of mutable aliasing and defined run-time behavior as long as code is written in a /safe/ context.
Refer to [[textcite:&rust-lang]].

For a summary of Rust in an embedded context, refer to [[textcite:&tjader2021rtic 6--8]].

**** [[Acrfull:PAC]]
# What is a PAC and what are they used for?
A PAC is a Rust library crate which exposes an [[gls:API]] for hardware peripherals.
Rather than providing an ad-hoc implementation inlined in an embedded application, a PAC provides a convenient interface to read and write to memory-mapped registers in order to mutate (in order to configure) and query (in order to poll the status of) hardware peripherals.

# Differentiate {architecture,device}-specific PACs
In the embedded Rust ecosystems, these are two kinds of PACs:
- architecture-specific :: Architecture-specific PACs expose an API for hardware peripherals common to all embedded systems that share the same architecture, commonly denoted as a "family". For example, ~cortex-m~ [[parencite:&cortex-m]] is a PAC that targets the ARM Cortex-M family of embedded systems, which is based on the ARMv7-M standard.
- device-specific :: Device-specific PACs expose an API for hardware peripherals available on a smaller family of embedded systems.
  For example, ~stm32-rs~ [[parencite:&stm32-pac]] is a collection of PACs targeting all microcontrollers in the STMicroelectronics STM32 family.

# svd2rust
A common tool to generate PACs is ~svd2rust~ [[parencite:&svd2rust]].

**** [[Acrfull:RTIC]]
:PROPERTIES:
:CUSTOM_ID: rtic
:END:

# TODO Expand: briefly cover rtic::app, how an application is declared, hardware tasks (PAC usage) and task dispatchers.
Hardware tasks are regular Rust functions that are bound to a hardware interrupt.
When this interrupt is made pending in hardware, the task function executes.
An example hardware task is declared via
#+name: rtic-hw-task-example
#+begin_src rust
  #[rtic::app]
  mod app {
      #[task(bound = EXTI0)]
      fn foo(_ctx: foo::Context) {
          // ...
      }
  }
#+end_src
With this declaration, =foo= will be executed when ~EXTI0~ is made pending in hardware.
After =foo= returns, the interrupt has been handled and ~EXTI0~ is no longer pending.


Software tasks are also regular Rust functions that are bound to hardware interrupts, but the bound hardware interrupt is not exclusively associated to the task in question: a single hardware interrupt can be associated with multiple software tasks.
For this reason, the used hardware interrupt is considered a "dispatcher".
An example software task is declared via
#+begin_src rust
  #[rtic::app(dispatchers = [EXTI0])]
  mod app {
      #[task]
      fn bar(_ctx: bar::Context) {
          // ...
      }
  }
#+end_src

In difference to hardware tasks, software tasks can be scheduled by software.
**** Hardware debuggers (probes)
# TODO required for a host system to flash and read data from an embedded system

*** Motivation
# We must cross a hardware boundry when debugging embedded systems.
Debugging the code being executed in an embedded system is an integral part of an embedded work-flow similar to how it is common to attach to and debug a process of a program being developed on a general-purpose computer.
The latter process can be considered trivial because no hardware boundries must be crossed; the debugger and debugged program are (usually) contained within the same system.
Debugging an embedded system is on the other hand non-trivial: the embedded system is its own contained system and a line of communication[fn:: Which requires a hardware debugger.] must be established with a host system to debug the embedded system.
\missingfigure{Draw a comparison between conventional debugging and embedded debugging.}

# We want to be able to debug in real-time (read: trace), but also record it.
An important aspect of debugging is the act of debugging in real-time, often referred to as the act of "tracing".
By tracing an embedded system it is possible to verify its internal operations continuously as long as a debugger is attached.
Another important aspect of debugging are post-mortem analyses: being able to analyse a system's run-time behavior before it ended up in an invalid or unexpected state after the fact.
Port-mortem analyses are realized by recording a trace from the attached debugger.
Such analyses are useful for systems deployed "in the field" which are seldom continuously controlled by human hands.
An example of such a system is a charger for electrical vehicles: verifying the operation of the charger is much easier before it is permanently installed at a parking space and expected to operate continuously.
If the charger breaks the responsible engineers will want to have a detailed log of events that occured before the device broke in order to improve it.

# Tracing is zero-cost by help of hardware, but not trivial to configure.
Tracing is supported by hardware debug facilities on the ARMv7-M platform, as is the exfiltration of the trace stream from the device (a line of communication which can be read by a host system).
Enabling and correctly configuring these facilites to generate a trace stream and decoding the trace stream itself is no trivial task, however.

# The emergence of RTIC, and its lack of debug tools.
RTIC is a novel RTOS which offers improvements over conventional RTOSs [[parencite:&tjader2021rtic 23]].
The motivation behind RTIC Scope is thus to offer a "batteries included"[fn:: where details regarding trace stream generation and decoding is abstracted, and where no additional work must be done to utilize the tool.] toolset that enables instant insight into an RTIC application.
Such a toolset would make it easier to verify the implementation of an RTIC application.

# Control application.
RTIC Scope will then be used to verify the implementation of a regulator for a complex dynamic system (see [[#control-application]]).
This is done in order to establish a base-line for the end-user experience of the toolset, in order to improve upon it; and provide an example where the toolset is applied to a realistic RTIC application, in the hopes of increasing the usage of RTIC and RTIC Scope. \todo{rephrase?}
The regulation of a complex dynamic system is chosen because an RTIC application for such a task is non-trivial, and it provides an ample opportunity to improve one's capabilities for control engineering.

*** Problem definition
:PROPERTIES:
:CUSTOM_ID: requirements
:END:
This thesis covers the development of an analysis toolset, RTIC Scope, that enables an RTIC application developer to gain non-invasive insight into the run-time of said application by exploiting the trace stream generated and exfiltrated by the debug facilities (see [[#debug-periphs]]) made available by the ARMv7-M standard, which RTIC supports by targeting Cortex-M platforms.

The set of /requirements/ RTIC Scope must fulfill within the scope of this thesis follows: RTIC Scope *MUST*[fn:: Interpreted as described in [[textcite:&rfc2119]].] be able to
1. <<req:itm-gen>> enable trace stream generation of hardware and software tasks (as defined by RTIC), and enable exfiltration of said trace stream from the device, by help of a target-side tracing library crate;
2. <<req:input>> read the generated trace stream via a hardware debugger or a serial device;
3. <<req:decode>> decode the trace stream to Rust structures;
4. <<req:rtic>> recover RTIC application metadata not contained within the trace stream;
5. <<req:timestamps>> associate timestamps to RTIC task events;
6. <<req:protocol>> report RTIC task events in real-time to the RTIC Scope end-user by use of a defined communication protocol.
7. <<req:dummy>> offer a reference implementation of a [[gls:frontend]] which implements the the protocol described in Requirement [[req:protocol]].
8. <<req:record>> record a trace to file which can be replayed offline; and
9. <<req:cargo>> be invoked as a ~cargo~ subcommand.

Delimitations to the above requirements apply, see [[#delimitations]].
*** Delimitations
:PROPERTIES:
:CUSTOM_ID: delimitations
:END:
In order to focus on the delivery of a robust toolset with proper implementation and documentation the scope of this thesis have been limited.
These /delimitations/[fn:: Uses the key words *MUST* and *SHOULD NOT* which are to be interpreted as described in [[textcite:&rfc2119]].], which are related to the requirements enumerated in [[#requirements]], are as follows:
1. Requirement [[req:itm-gen]]: RTIC Scope *MUST* apply the device mutations that are common to all ARM Cortex-M targets in order to enable trace stream generation and exfiltration. RTIC Scope *SHOULD NOT* apply device-specific mutations.
2. Requirement [[req:input]]: RTIC Scope *SHOULD NOT* have to ensure that a trace stream is read from the device; that responsibility falls upon the RTIC Scope end-user. However, RTIC Scope *MUST* fail or warn the end-user if it is unable to correctly decode the read data stream.
3. Requirement [[req:rtic]]: RTIC Scope *MUST* support RTIC version 1.0.0, see [[textcite:&rtic]].
   RTIC Scope *MUST* must recover metadata necessary to report the timestamped status of hardware and software tasks, as defined by RTIC.
4. Requirement [[req:protocol]]: The defined communication protocol *MUST* enable one-way communication from the ~cargo~ subcommand /backend/ to the reference /frontend/. The protocol *SHOULD NOT* enable two-way communication.

Following the above delimitations allows this thesis to be finished within an acceptable time frame[fn:: As defined by the author, i.e. not necessarily the recommended time frame as defined by the X7009E course taken at LuleÃ¥ Technical University during which this thesis is written.] and also to yield a documented code base which allows future development with minimal friction.

The use of the key words *MUST* and *SHOULD NOT* used above as to be interpreted as described in [[textcite:&rfc2119]].

*** Contributions
The development of RTIC Scope has yielded a number of [[gls:downstream]] contributions, namely a collection of crates:
- ~cargo-rtic-scope~ :: A ~cargo~ subcommand acting as the RTIC Scope backend (or host-side /daemon/) which fulfill Requirements [[req:input]]--[[req:protocol]] and [[req:record]]--[[req:cargo]].
  See [[#impl:cargo-rtic-scope]] and [[textcite:&rtic-scope:cargo-rtic-scope]].
- ~rtic-scope-frontend-dummy~ :: A reference implementation of a RTIC Scope frontend, which fulfill Requirement [[req:dummy]].
  See [[#impl:rtic-scope-frontend-dummy]] and [[textcite:&rtic-scope:dummy]].
- ~rtic-scope-api~ :: The communication protocol the ~cargo-rtic-scope~ uses to report RTIC task events in real-time to ~rtic-scope-frontend-dummy~, as described by Requirement [[req:protocol]].
  See [[#impl:api]] and [[textcite:&rtic-scope:api]].
- ~cortex-m-rtic-trace~ :: An auxilliary target-side crate that properly configure the device for trace stream generation and exfiltration, which fulfills Requirement [[req:itm-gen]].
  See [[#impl:rtic-trace]] and [[textcite:&rtic-scope:rtic-trace]].
- ~itm~ :: A library crate for decoding the trace stream exfiltrated from the embedded system, which fulfill Requirements [[req:decode]] and [[req:timestamps]] (partially).
  See [[#impl:itm]] and [[textcite:&itm]].

Of certain note it ~itm~ which ~cargo-rtic-scope~ relies on: its implementation does not rely on RTIC and can be used independently of RTIC Scope; ~itm~ can be used to decode trace stream generated by a target using an RTOS other than RTIC.
Because of this general nature and detachment from RTIC Scope it must not necessarily be a part of the RTIC Scope project itself, but is as of writing for reasons of convenience.
See [[#disc:itm-embedded-wg]] for a discussion on under what banner ~itm~ belongs.

Further, a number of [[gls:upstream]] contributions have been made to the crates which RTIC Scope depends on.
An exhaustive summary of these contributions are described below (listed in no particular order).

- ~probe-rs/probe-rs~ ::
  A "a modern, embedded debugging toolkit, written in Rust" [[parencite:&probe-rs]] utilized to fulfill Requirement [[req:input]].
  Contributions are:
  - /Reintroduce ~CargoOptions~ in ~mod common_options~/: patch set included in a larger refactor [[parencite:&pr:probe-rs:760]].
  - /arm: enable exception trace on ~setup_swv~/: improves tracing support for ARM targets [[parencite:&pr:probe-rs:758]].
  - /cargo: bump bitvec/: updates a dependency [[parencite:&pr:probe-rs:757]].
  - \textit{arm/itm: doc fields, enable global timestamps}: improves documentation [[parencite:&pr:probe-rs:728]].
  - \textit{Add generic probe/session logic from cargo-flash}: improves composability with RTIC Scope [[parencite:&pr:probe-rs:723]].
  - \textit{deprecate internal ITM/DWT packet decoder in favour of itm-decode}: replaces an unfinished internal trace stream decoder with an ~itm~ precursor; see [[#impl:itm]] [[parencite:&pr:probe-rs:564]].

  Refer to [[#impl:cargo-rtic-scope]] for a detailed description of the usage of this toolkit.
- ~probe-rs/cargo-flash~ ::
  A "cargo extension for programming microcontrollers" [[parencite:&cargo-flash]], functionality of which is used by ~cargo-rtic-scope~.
  Contributions are:
  - /move probe, session logic, flash downloader to probe-rs-cli-util/: moves functionality from ~cargo-flash~ to an auxilliary ~probe-rs~ library crate such that they can be utilized by ~cargo-rtic-scope~ [[parencite:&pr:cargo-flash:188]].

- ~rust-embedded/cortex-m~ :: A library crate that enables "low level access to Cortex-M processors" [[parencite:&cortex-m]], utilized to fulfill Requirement [[req:itm-gen]], [[req:decode]] and [[req:record]].
  Contributions are:
  - /scb: derive serde, Hash, PartialOrd for VectActive behind gates/: adds features used by ~itm~ [[parencite:&pr:cortex-m:363]].
  - /Implement various interfaces for trace configuration/: adds features used by ~cortex-m-rtic-trace~ [[parencite:&pr:cortex-m:342]].
  - \textit{TPIU: swo\textunderscore supports: make struct fields public, improve documentation}: fixes an issue in a library module and improves documentation [[parencite:&pr:cortex-m:381]].
  - /CHANGELOG: add missing items/: adds documentation about added features [[parencite:&pr:cortex-m:378]].
  - /itm: derive serde for \texttt{LocalTimestampOptions}, impl gated \texttt{TryFrom<u8>}/: adds features used by ~cargo-rtic-scope~  [[parencite:&pr:cortex-m:366]].
  - /ITM: check feature support during configuration, add busy flag, docs improvement/: ensures hardware support during trace stream generation configuration [[parencite:&pr:cortex-m:383]].

  Refer to [[#impl:rtic-trace]] and [[#impl:itm]] for a detailed description of the usage of this library.
- ~rtic-rs/rtic-syntax~ :: A crate that defines and parses the RTIC meta language [[parencite:&rtic-syntax]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - \textit{improve error string if parse\textunderscore binds is not set}: improves documentation when the crate is used as a library [[parencite:&pr:rtic-syntax:47]].
- ~rtic-rs/cortex-m-rtic~ :: The RTIC implementation for Cortex-M platforms [[parencite:&rtic]].
  Contributions are:
  - \textit{book/migration/v5: update init signature, fix example syntax}: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:480]].
  - /book: detail import resolving for 0.6 migration/: improves documentation for migration to an updated version of RTIC [[parencite:&pr:rtic:479]].
  - /book: update outdated required init signature/: improves RTIC examples in documentation [[parencite:&pr:rtic:478]].
- ~Michael-F-Bryan/include_dir~ :: A crate for embedding file trees in a binary [[parencite:&includedir]], utilized to fulfill Requirement [[req:rtic]].
  Contributions are:
  - /Dir: add extract-to-filesystem functionality/: implements functionality for extracting embedded file trees to disk [[parencite:&pr:includedir:57]].
  - \textit{dir/extract: add mode for overwriting existing files}: implements functionality for overwriting existing files when extracting embedded file trees to disk [[parencite:&pr:includedir:65]].

*** Outline
 This paper is structured as follows
 - Introduction :: provides an introduction to Rust, RTIC, ARMv7-M hardware peripherals of interest, and the RTIC Scope project.
 - Previous work :: presents work previously done in the same domain, which this thesis builds upon.
 - Related work :: presents some tools similar to the features of RTIC Scope.
 - Implementation :: covers the implementation of RTIC Scope and the ~itm~ crate.
 - Results :: TODO
 - Discussion :: TODO
 - Conclusions :: TODO
 - Future work :: TODO
 - Appendices :: TODO

** Previous and Related Work
*** Related work
# TODO convert to references
Some toolsets similar to RTIC Scope were already available before the start of this thesis, namely:
- orbuculum :: https://github.com/orbcode/orbuculum, an ARM Cortex-M trace stream demuxer and post-processor;
- Percepio Tracealyzer :: https://percepio.com/tracealyzer/, proprietary visual trace diagnostic tool that supports a multitude of platforms and RTOSs.

Neither of the tools support RTIC, nor have any inspiration been taken from them during the development of RTIC Scope.

*** Previous work
The implementation of RTIC Scope stands of the shoulders of countless developers that have enabled the implementation of the toolset within the frame of this thesis.
Of certain note are
- ~cortex-m~ :: that enable low-level access to Cortex-M processors;
- ~probe-rs~ :: an extensible embedded debugging toolkit;
- ~rtic-syntax~ :: RTIC meta language parser library; and
- ~itm~ (version 0.3) and ~itm-tools~ :: library and tools for analyzing ITM traces.

For a full list of dependant crates used by RTIC Scope, execute
#+begin_src shell
  $ cargo install cargo-tree
  $ git clone https://github.com/rtic-scope/cargo-rtic-scope.git && cd cargo-rtic-scope
  $ cargo tree
#+end_src

** Theory
This chapter covers the theory, tools, and the ARMv7-M hardware features utilized in order to develop RTIC Scope.
*** ARMv7-M debug facilities
:PROPERTIES:
:CUSTOM_ID: debug-periphs
:END:
This section summarizes the [[Acrfull:ITM]] packet protocol and the hardware peripherals responsible for its generation and device exfiltration.
For sake of brevity this section is not exhaustible and only covers the subset of ITM packets that RTIC Scope utilizes as of version v0.3.0 [[parencite:&rtic-scope]].
For more information on each peripheral, refer to the respective sections in [[textcite:&arm-rm]].

# DWT -> ITM -> TPIU -> ETB.
RTIC Scope utilizes the [[Acrfull:DWT]], ITM, [[Acrfull:TPIU]], and [[Acrfull:ETB]] peripherals for on-target trace generation and trace extraction.
The DWT and ITM peripherals are sources of ITM protocol packets which are forwarded to the TPIU and ETB for device exfiltration via serial communication.
\missingfigure{Draw the DWT -> ITM -> TPIU -> ETB relationship.}

These peripherals are summarized below.

**** [[Acrfull:DWT]]
# Summarize DWT functionality exploited in RTIC Scope
# TODO "responsible for hardware events"
The DWT peripheral provides the core of the utilized hardware tracing functionality by generating packets when
- a configured range of data is read or written by help of hardware comparators (known as "data tracing"); and
- whenever the processor enters an exception handler and returns from it (known as "exception tracing").
Thus, tracing of hardware-bound RTIC tasks can be achieved by intercepting exception trace packets, and software tasks can be traced by writing a unique task identifier to a monitored address and intercepting the data trace packets.

# DWT comparators /can/ trace RTIC resources, but its complex
# TODO move to future work
# RTIC resources can theoretically also be traced by help of DWT comparators, but such as approach would be relatively complex.
# A data trace value packet contains up to one word (32 bits) of information.
# If the RTIC resources fits within a word only a single packet must be intercepted.
# However, a more common praxis is the usage of non-primitive resources which have differing sizes between an debug and optimized build of the target application.
# The more common case is then the need to intercept multiple data trace value packets from which the resources must be reconstructed.
# The need to emit more packets increases the possibility of DWT buffer overflows events, during which the packet is dropped and an overflow packet is generated instead.
# Of note is that the overflow packet does not contain any information on what caused the overflow.
# Assuming that all packets can be send and intercepted without buffer overflows, the issue of reconstucting the most-likely non-primitive data structures remain.
# This requires DWARF information and is a project on its own.

All the packets generated by the DWT unit are known as "hardware event packets" and are sent to the ITM unit and then forwarded to the TPIU.

Refer to [[textcite:&arm-rm C1.8]] for more information on the DWT unit.
**** [[Acrfull:ITM]]
# Summarize ITM functionality
The ITM unit is of an auxilliary nature; it has three functions:
- the multiplexing of hardware event packets from the DWT unit with its own instrumentation packets which are then forwarded to the TPIU;
- control and generation of timestamp packets; and
- a memory-mapped register interface that allows logging of arbitrary data via a maximum of 256 stimulus registers, unused by RTIC Scope.

# Summarize timestamp packets
Timestamp packets are appended to a set of non-timestamp packets that occur at a common timestamp and come in two forms: global and local.
# TODO when exactly is the time counting started?
Global timestamps are absolute and starts counting at the boot of the target device.
Local timestamps are relative to the last local timestamp and resets its count when a new one is generated.
An up-to-date absolute timestamp can be calculated by applying all local timestamp values upon the last global timestamp.
For example, if a global timestamp with the value $10$ is emitted after which two local timestamps with the respective values of $3$ and $4$ are emitted, an up-to-date absolute timestamp is calculated via $10 + 3 + 4 = 17$.
Local timestamps also contain information on the relationship between the local timestamp generation and the corresponding trace packets. The timestamp can be
- synchronous to the generated packets: the timestamp is the counter value when the non-timestamp packets were generated;
- delayed relative to the packets: the timestamp is the counter value when the timestamp packet was generated (the local timestamp value corresponding to the non-timestamp packet generation event is thus unknown, but must be between the previous and current local timestamp value);
- delayed relative to the associated event: synchronous to the generated packets, but the packets themselves were delayed because of other trace output packets; or
- delayed relative to the packets and associated event: a combination of the last two conditions.

# TODO explain what clock drives the global timestamp clock (P710)
# TODO document sync packets (P712)
# TODO document arbitration between packets from different sources (P713)

# TODO Instrumentation packets and RTIC resource tracing
# 32b per stim register, each has a FIFOREADY bit, each instrumentation packet contains at max 4B = 32b
# port number, 0-31

# XXX ITM stims has its own output buffer not related to the DWT output buffer, the status of the ITM output buffer can be queried via FIFOREADY in ITM_STIMx

# TODO add an example figure how a collection of back-to-back trace packets may look like. Timestamp is last in the chain

For more information on the ITM unit, refer to [[parencite:&arm-rm C1.7]]. For more information on global and local timestamps, refer to  [[parencite:&arm-rm C1-710]].
**** [[Acrfull:TPIU]]
# Summarize TPIU functionality
The TPIU provides external visibility of the trace packet stream by serializing...

by serializing these over a set of exposed hardware pins or via the MCU programmer unit (depending on target platform).
Depending on the platform, these can be GPIO pins which can be configured in parallel mode by use of multiple pins or a singular GPIO pin for an asynchronous port.

# Embedded Trace Buffer (ETB), SWO, or parallel trace port

For more information on the TPIU, refer to [[parencite:&arm-rm C1.10]].

# TODO recreate Fig. C1-1 from [[pdf:~/exjobb/thesis/docs/DDI0403E_d_armv7m_arm.pdf::713++0.00][DDI0403E_d_armv7m_arm.pdf: Page 713]] without ETM component.

# XXX The combination of the DWT and ITM packet stream and an asynchronous Serial Wire Output (SWO) is called a Serial Wire Viewer (SWV)
**** [[Acrfull:ETB]]

** Implementation
This section covers the implementation of ~cargo-rtic-scope~, ~cortex-m-rtic-trace~, and ~rtic-scope-frontend-dummy~ of RTIC Scope and the implementation of ~itm~.
First of, the usage of the ~cortex-m-rtic-trace~ and the notable /preparatory recovery step/ of ~cargo-rtic-scope~ is covered after which the implementation is presented in a downstream manner: that is, how
1. the trace stream exfiltrates via the [[ACRshort:TPIU]];
2. ~cargo-rtic-scope~ reads the raw trace stream from the source;
3. ~itm~ decodes this stream into manageable Rust structures;
4. ~cargo-rtic-scope~ recovers RTIC metadata for the decoded trace stream;
5. this resolved trace stream is forwarded to frontends; and
6. how a frontend handles a trace stream.

\missingfigure{Draw the data flow in RTIC Scope: DWT to ITM to TPIU to cargo-rtic-scope and the itm crate, to replay file and frontends.}

*** ~cortex-m-rtic-trace~ and its application
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace
:END:
~cortex-m-rtic-trace~ is an auxilliary target-side crate that configures all relevant Cortex-M peripherals --- namely the [[acrfull:DCB]][fn:: A component of the [[acrfull:SCB]] peripheral.], [[ACRshort:TPIU]], [[ACRshort:DWT]], and [[ACRshort:ITM]] -- for tracing.
The crate exposes two functions:
- ~cortex_m_rtic_trace::configure~ :: a regular Rust function for configuration of the peripherals mentioned above; and
- ~cortex_m_rtic_trace::trace~ :: a Rust macro with with to trace software tasks.
Henceforth, within this section, these two functions will be referred to as ~configure~ and ~trace~, respectively.

This section is divided into two parts: [[cref:impl:rtic-trace:peripheral-config]], which covers the application of ~configure~; and [[cref:impl:rtic-trace:trace-macro]], which covers the application of the ~trace~ macro.

**** Peripheral configuration
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:peripheral-config
:END:
After applying device-specific configurations for trace generation, and querying the frequency of the [[ACRshort:TPIU]] reference clock, ~configure~ is applied as shown in [[cref:lst:rtic-trace:configure]].
#+NAME: lst:rtic-trace:configure
#+CAPTION: Example application of ~cortex_m_rtic_trace::configure~.
#+begin_src rust
  #[init]
  fn init(mut ctx: init::Context) -> (SharedResources, LocalResources, init::Monotonics()) {
      // device-specific configurations for trace stream generation...

      let freq = {
          // device-specific query for the TPIU reference clock
          // frequency...
      };

      use cortex_m_rtic_trace::{
          self, GlobalTimestampOptions, LocalTimestampOptions, TimestampClkSrc,
          TraceConfiguration, TraceProtocol,
      };

      // configure device-common tracing
      cortex_m_rtic_trace::configure(
          &mut ctx.core.DCB,
          &mut ctx.core.TPIU,
          &mut ctx.core.DWT,
          &mut ctx.core.ITM,
          1, // task enter DWT comparator ID
          2, // task exit DWT comparator ID
          &TraceConfiguration {
              delta_timestamps: LocalTimestampOptions::Enabled,
              absolute_timestamps: GlobalTimestampOptions::Disabled,
              timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
              tpiu_freq: freq, // Hz
              tpiu_baud: 9600, // B/s
              protocol: TraceProtocol::AsyncSWONRZ,
          },
      )
      .unwrap();

      // ...
  }
#+end_src

~configure~ in [[cref:lst:rtic-trace:configure]] does a number of things in the following order:
1. <<rtic-trace:conf-protocol>> ensures that the target's [[ACRshort:TPIU]] peripheral supports the requested ~protocol~ by reading the [[acrfull:TPIU_TYPE]] [[parencite:&arm-rm C1.10.6]];
2. ensures that the user did not request an invalid [[ACRshort:TPIU]] configuration (i.e. ~tpiu_freq: 0~ or ~tpiu_baud: 0~);
3. <<rtic-trace:conf-exception-trace>> ensures that the target's [[ACRshort:DWT]] peripheral supports exception tracing by reading the /NOTRCPKT/ bit in [[acrfull:DWT_CTRL]] [[parencite:&arm-rm C1.8.7]];
4. <<rtic-trace:nofail-conf>> configures the [[ACRshort:DCB]], [[ACRshort:TPIU]], and [[ACRshort:DWT]] peripherals (partially):
   1. sets the /TRCENA/ bit in the [[acrfull:DCB_DEMCR]], a "global enable for all [[ACRshort:DWT]] and [[ACRshort:ITM]] features";
   2. calculates and writes a prescaler to the /SWOSCALER/ bitrange in the [[acrfull:TPIU_ACPR]] such that the [[ACRshort:TPIU]] communicates with a requested baud rate.
      The prescaler is calculated via [[cref:eq:prescaler]] as derived from [[textcite:&arm-rm C1.10.4]].[fn:: This configuration implementation is faulty. See [[cref:fut:swoscaler]].]
      #+NAME: eq:prescaler
      \begin{equation}
      \frac{\texttt{tpiu\textunderscore freq}}{\texttt{tpiu\textunderscore baud}} - 1
      \end{equation}
   3. drops any [[acrfull:ETM]] packets that the [[ACRshort:TPIU]] receives because the utilization of these packets are outside the scope of this thesis; and
   4. sets the /EXCTRCENA/ bit in [[acrshort:DWT_CTRL]] which enables the generation of exception traces in the [[ACRshort:DWT]] [[parencite:&arm-rm C1.8.7]].
5. <<rtic-trace:itm>> Applies [[ACRshort:ITM]]-related options given to ~configure~ by writing to the [[acrfull:ITM_TCR]] while also checking for target support for the requested configuration [[parencite:&arm-rm C1.7.6]]:
   1. sets the /ITMENA/, /TXENA/, /SWOENA/, and /TSENA/ bits which enables the [[ACRshort:ITM]], forwards trace packets from the [[ACRshort:DWT]] to the [[ACRshort:ITM]], "enables asynchronous clocking of the timestamp counter", and enables the generation of local timestamps, respectively;
   2. writes 0 to the /TraceBusID/ field because RTIC Scope does not support multi-source tracing within the scope of this thesis[fn:: Writing 0 to this field is potentially invalid. See [[cref:fut:TraceBusID]].]
   3. writes 0 to the /TSPrescale/ field, disabling prescaling for local timestamps; and
   4. writes 0 to the /GTSFREQ/ field, disabling global timestamps.[fn:: Global timestamps are an optional feature, and is not supported by all Cortex-M targets.]
6. <<rtic-trace:dwt>> Configures [[ACRshort:DWT]] comparators for software task tracing:
   1. first, resolves the target addresses of two =u32= /watch variables/ which live in [[gls:elf:data]];
   2. dereferences two [[ACRshort:DWT]] comparators as specified by the 5th and 6th arguments to ~configure~ in [[cref:lst:rtic-trace:configure]];[fn:: The [[ACRshort:API]] for specifying these comparators can be greatly improved. See [[cref:fut:dwtcomps]].]
   3. configures the first comparator to signal a match (and generate an associated trace stream packet) when data is written to the first watch variable:
      1. writes to seven fields in the [[acrfull:DWT_FUNCTIONn]][fn:dwt-n] [[parencite:&arm-rm C1.8.17]], where $n$ is the offset of the comparator (in the context of [[cref:lst:rtic-trace:configure]], $1$):
         0b1101 to /FUNCTION/, configuring the comparator to match on address access;
         0 to /EMITRANGE/, disabling trace address packet generation;[fn:: We are not interested in the address that contains the watch variable.]
         0 to /DATAVMATCH/, to disable data value comparison;
         0 to /CYCMATCH/, to disable cycle counter comparison;
         and 0 to /DATAVSIZE/, /DATAVADDR0/, and /DATAVADDR1/ because these fields are [[acrfull:SBZ]] [[parencite:&arm-rm Glossary-855]] in address comparison context.
      2. writes the first watch variable address to [[acrfull:DWT_COMPn]][fn:dwt-n] (with $n = 1$), in order for the comparator to match on that address access; and
      3. writes 0 to [[acrfull:DWT_MASKn]][fn:dwt-n] ($n=1$), such that the comparator does not match on a range of addresses.
   4. Lastly, the second comparator is configured in the same manner as the first, but with the second watch variable address in mind and $n=2$.

If any step in [[crefrange:rtic-trace:conf-protocol,rtic-trace:conf-exception-trace]] fails ~configure~ prematurely returns an ~Err(_)~ that signals what went wrong, and no peripheral configuration will have been applied: the target will be in the same state as before ~configure~ was called.

Several fields in [[ACRshort:ITM_TCR]] are potentially [[acrfull:RAZ-WI]], [[acrfull:RAZ]], or [[acrfull:RAO]] [[parencite:&arm-rm Glossary-854]] in order to signal hardware support.
This requires the field to be read after a write to ensure that a configuration was applied.
During the steps in [[cref:rtic-trace:itm]], if any read-back values does not match what was written, ~configure~ prematurely returns an ~Err(_)~ signalling what configuration component was not supported by the target and what components have been successfully applied, notifying the end-user that a partial configuration has now been applied.
It is up to the end-user to reset the target to the state before ~configure~ was called.
For a discussion on this implementation detail, see [[textcite:&issue:cortex-m:382]].

The steps in \cref{rtic-trace:nofail-conf,rtic-trace:dwt} and cannot fail.

Of certain note are the steps in [[cref:rtic-trace:dwt]] because of the dependency of variables in ~.data~ to trace software tasks, and how the watch variables in this section are aligned in memory.
The [[ACRshort:DWT]] comparators are configured to match on writes to singular addresses which are represented as =u32= variables.
However, due to performance reasons, the watch variables are represented as =u8= variables: only a single byte will be written to these 32-bit addresses during run-time tracing (see [[cref:impl:rtic-trace:trace-macro]]).
Further, because of time constrains no experimentation has been done with a non-zero mask: this requires the watch variables to be aligned to 32-bits. For more on the topic of performance, see [[cref:disc:perf]] and [[cref:fut:opt-dwt-units]].
\todo{improve this paragraph.}

**** Tracing software tasks with ~trace~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-trace:trace-macro
:END:

*** The ~cargo-rtic-scope~ recovery step
# How hardware tasks are traced
The ITM packet protocol allows us to trace both hardware and software tasks.
Hardware tasks are traced via exception trace packets.
These are emitted when an interrupt handler is entered, exited, or returned to from another interrupt handler that preempted it with a higher priority.
This packet contains two fields of information: the IRQ number of the associated interrupt handler, and whether the handler was entered, exited, or returned to.

# How software tasks are traced
Software tasks are traced via data trace value packets.
These are emitted when a watch address is written to, given that a DWT comparator is properly configured.
A watch address can be any address that the user code have access to.
This packet contains three fields of information: the DWT comparator number that registered the match, whether the watch address was written to or read, and the value written to or read from the watch address.

# We need to recover information to associate packets to RTIC task events
These two packets cannot be associated to RTIC tasks on their own.
The recovery step of RTIC Scope must thus generate host-side lookup maps that map IRQ numbers to hardware tasks and data trace values and DWT comparator numbers to software tasks.
These translation maps are aptly named the =recovery::SoftwareMap= and =recovery::HardwareMap=.
Together they constitute the information available in a =recovery::TraceLookupMaps=.

**** Generating the =recovery::HardwareMap=
# Overview: what to we need?
In order to generate a =recovery::HardwareMap= the RTIC application declaration must be parsed.
This is done when the RTIC app is built via =cargo build= when the =#[rtic::app(...)]= macro is expanded by help of ~rtic_syntax::parse{,2}~ functions which yelds yields (among other) a =rtic_syntax::App=.
This structure is not communicated to RTIC Scope which means that the RTIC app must be parsed one additional time.

# We must the source for the ASTs
In order to generate a =rtic_syntax::App= for recovery purposes =rtic_syntax::parse2= must be called directly with the arguments of =#[rtic::app(..)]= and with the input to the macro.
For example, in [[lst:recovery-example]], =device = stm32f4::stm32f401= is the macro arguments, and =mod app { ... }= is the macro input.
#+CAPTION: Example RTIC application declaration for execution on the STMicroelectronics STM32 NUCLEO-F401RE.
#+NAME: lst:recovery-example
#+begin_src rust
  #[rtic::app(device = stm32f4::stm32f401)]
  mod app {
      #[shared]
      struct Shared {}

      #[local]
      struct Local {}

      #[init]
      fn init(mut ctx: init::Context) -> (Shared, Local, init::Monotonics) {
          // ...
          (Shared {}, Local {}, init::Monotonics())
      }

      #[task(binds = SysTick)]
      fn task1(_: task1::Context) {
          // ...
      }

      #[task(binds = EXTI1)]
      fn task2(_: task2::Context) {
          // ...
      }
  }
#+end_src
However, these [[gls:AST][AST]] are not readily available without further preparatory work; they must first be extracted from the source file containing [[lst:recovery-example]].

# But wait: where is the source file?
To find the source file, the RTIC app must first be built. This is done via =build::CargoWrapper::new= [fn:recovery-build] which intercepts the output of =cargo build --message-format=json-diagnostic-rendered-ansi= by help of the =cargo_metadata= crate.
This output contains the absolute path to the source file that contains [[lst:recovery-example]].

# Skipping tokens
With the source file readily available it is parsed as a [[gls:tokenstream][tokenstream]] by skipping [[gls:token][token]] until =#[rtic::app]= is found, after which the =rtic_syntax= parsing explained above is done.

# known and unknown maps
At this point we have the necessary =rtic_syntax::App= structure to continue: =rtic_syntax::App::hardware_tasks= is a collection of =rtic_syntax::HardwareTask= that lists what interrupt handler each hardware task is bound to via the =binds= argument in =#[task(binds = ...)]=.
After parsing [[lst:recovery-example]], =hardware_tasks= contains [fn:: abstracted for brevity.]
#+begin_export latex
$$
\langle \text{\texttt{app::task1} binds to \texttt{SysTick}} \rangle, \langle \text{\texttt{app::task2} binds to \texttt{EXTI1}} \rangle
$$
#+end_export
Of these, the =app::task1= bind is considered known, and the =app::task2= bind is considered unknown.
A known bind is one that no more recovery work must be applied on.
This follows from the specification of the exception trace packet: [[tbl:irqns]] enumerates all numbers that can be in the packet's IRQ field.
All $\text{IRQn} < 16$ are common to all ARMv7-M targets, the name of which can be directly mapped to the RTIC task that binds the IRQ name.
All $\text{IRQn} \geq 16$ on the other hand, are not common to all ARMv7-M, and are thus treated as platform-specific because the labels (specified via =#[task(binds = ...)]=) are unknown.
Additional recovery must be done to find these labels.

#+CAPTION: ARMv7-M Exception/IRQ numbers and names. Copied from [[parencite:&arm-rm Table B1-4]].
#+NAME: tbl:irqns
#+ATTR_HTML: :rules all
| Exception number | Exception name/label   |
|------------------+------------------------|
|                1 | Reset                  |
|                2 | NMI                    |
|                3 | HardFault              |
|                4 | MemManage              |
|                5 | BusFault               |
|             7-10 | Reserved               |
|               11 | SVCall                 |
|               12 | DebugMonitor           |
|               13 | Reserved               |
|               14 | PendSV                 |
|               15 | SysTick                |
|               16 | External interrupt 0   |
|                . | .                      |
|                . | .                      |
|                . | .                      |
|         16 + $N$ | External interrupt $N$ |
|------------------+------------------------|

# PAC::Interrupt and known/unknown partitioning; Rust reflection woes
For any RTIC application, the labels are available in the =PAC::Interrupt= enum. For [[lst:recovery-example]], =PAC= is =stm32::stm32f401=.
An example declaration of such an enum can be seen in [[lst:pac-interrupt-example]].
#+NAME: lst:pac-interrupt-example
#+CAPTION: Example declaration of a =PAC::Interrupt= enum. Left-hand side of =Interrupt= is the IRQ label; right-hand is $N$ in [[tbl:irqns]].
#+begin_src rust
  pub mod PAC {
      #[derive(Debug)]
      #[repr(u16)]
      pub enum Interrupt {
          PVD = 1,
          EXTI0 = 6,
          EXTI1 = 7,
          // ...
      }

      unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
          #[inline(always)]
          fn number(self) -> u16 {
              self as u16
          }
      }
  }
#+end_src
By finding the label used in =#[task(bind = ...)]= in =PAC::Interrupt= we find what enum constructor to use.
With the enum in hand, we construct it and get the IRQ number offset $N$ via
#+begin_src rust
  let label = PAC::Interrupt::EXTI1;
  assert_eq!(label.number(), 7);
#+end_src
To get the IRQ number of this unknown bind we simly sum it with $16$, as documented by [[tbl:irqns]]:
#+begin_src rust
  let irq_nr = label.number() + 16;
  assert_eq!(irq_nr, 23);
#+end_src
This process is unfortunately non-trivial: Rust does not have dynamic programming features and an ideal evaluation function of
#+begin_src rust
  fn resolve_irq_nr(label: &str) -> u16 {
      quote!(PAC::Interrupt::$label).eval().number() + 16;
  }
#+end_src
is not realizable.

# libadhoc
Enter =recovery::resolve_int_nrs=: given a list of labels, the function
1. extracts an embedded file tree constituting a crate to the RTIC application's ~target/cargo-rtic-trace-libadhoc~;
2. adds a user-specified crate dependency for the PAC in ~Cargo.toml~;
3. for each label: adds a non-mangled function with the same name as the label that returns the associated IRQ number offset, $N$ (for [[lst:recovery-example]] the generated code can be seen in [[lst:resolve_int_nrs-example]]);
   #+NAME: lst:resolve_int_nrs-example
   #+begin_src rust
     #[no_mangle]
     pub extern fn EXTI1() -> u16 {
         Interrupt::EXTI0.number()
     }
   #+end_src
4. builds the crate as a cdylib[fn:cdylib];
5. loads the library into memory;
6. for each label: calls the associated function in the library to get the offset $N$ and sums it with 16; and
7. collects the results.
This collection then merges with the collection of known maps.

# user-supplied information
The last piece of the puzzle is from where to source user-supplied information.
Four fields of information is required to complete the second step above: the PAC name, version, features (if any), and the path to the =PAC::Interrupt= enum.
There are two methods the user can supply this information: via commandline options, see [[lst:recovery-user-info-cmdopt]];
or by entering the fields into the ~rtic-scope~ metadata block of the application's ~Cargo.toml~, see [[lst:recovery-user-info-toml]].
PAC information in ~Cargo.toml~ is persisent, and simplifies an iterative workflow.

#+NAME: lst:recovery-user-info-cmdopt
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via command line options.
#+begin_src shell
  $ cargo rtic-scope trace --pac-name stm32f4 --pac-version 0.13 --pac-features stm32f401 --pac-features some-other-feature --interrupt-path "stm32f4::stm32f401::Interrupt"
#+end_src

#+NAME: lst:recovery-user-info-toml
#+CAPTION: Supplying information to RTIC Scope for recovery purposes via ~Cargo.toml~ metadata.
#+begin_src toml
# ...

[package.metadata.rtic-scope]
pac_name = "stm32f4"
pac_features = ["stm32f401", "some-other-feature"]
pac_version = "0.13"
interrupt_path = "stm32f4::stm32f401::Interrupt"

# ...
#+end_src

**** Generating the =recovery::SoftwareMap=
The work to generate a =recovery::SoftwareMap= is similar to that of a =recovery::HardwareMap=.
The intercepted data trace value packet contains a DWT comparator number, a payload, and whether the watch address was written to or read.
~cortex-m-rtic-trace~ ensures that the DWT only matches on writes, so packets that indicate a read are forwarded as an unknown event: only the comparator number and payload are of interest.

# TODO two dwt channels are used: one for exits and one for enters. Each write is u8.
# TODO parsing and how we associate an UID to each task
# TODO tracing nested functions
# TODO task dispatchers, the events of which are ignored

*** Reading the raw trace stream from the source with ~cargo-rtic-scope~
:PROPERTIES:
:CUSTOM_ID: impl:cargo-rtic-scope
:END:
~cargo-rtic-scope~ is a host-side daemon that fulfills [[crefrange:req:input,req:protocol]] and [[crefrange:req:record,req:cargo]].
It is run like a ~cargo~ subcommand, as seen in [[cref:lst:cargo-rtic-scope:summary]], where ~<verb>~ is either ~trace~ or ~replay~.
As the verbs imply, ~trace~ is used to trace the execution of an RTIC application on the target and ~replay~ is used to replay a trace for post-mortem analysis.
#+NAME: lst:cargo-rtic-scope:summary
#+CAPTION: Summary of ~cargo-rtic-scope~ invocation.
#+begin_src shell
  $ cargo rtic-scope [options...] <verb> [options...]
#+end_src

This section covers the options of these verbs, the general implementation of ~cargo-rtic-scope~, and insight into some choice components of the code base.

**** Embedded Trace Buffer
# TODO look up coresight documentation and summarize its operation

**** TPIU
# TODO the different modes, multiple pins, baud rate and clock

*** Decoding the ITM packet stream via ~itm~
:PROPERTIES:
:CUSTOM_ID: impl:itm
:END:
# TODO the decoding part, draw/borrow some figures from standard
# TODO iter.rs, specifically Timestamps, timestamp formula, GTS logic, etc.
# TODO everything is unit tested.

*** Associating trace packets with RTIC task events
# TODO build_event_chunk

*** Forwarding resolved trace stream to sinks via ~rtic-scope-api~
:PROPERTIES:
:CUSTOM_ID: impl:api
:END:

*** Echoing the trace stream with ~rtic-scope-frontend-dummy~
:PROPERTIES:
:CUSTOM_ID: impl:rtic-scope-frontend-dummy
:END:

** Results
*** Using RTIC Scope
From an end-user perspective RTIC Scope offers a "batteries-included" toolset that enables great insight into a target RTIC applications,
provided that a small set of limitations are adhered to and specific metadata is added to the application crate in question.
To install RTIC Scope, an end-user executes
#+begin_src shell
  $ cargo install cargo-rtic-scope
  $ cargo install rtic-scope-frontend-dummy
#+end_src
and adds the following metadata to their RTIC application's ~Cargo.toml~:
#+begin_src toml
  [package.metadata.rtic-scope]
  # necessary information for RTIC metadata recovery
  pac_name = "stm32f4"
  pac_features = ["stm32f401"]
  pac_version = "0.13"
  interrupt_path = "stm32f4::stm32f401::Interrupt"

  # ITM/DWT/TPIU parameters
  tpiu_freq = 16000000
  tpiu_baud = 115200
  dwt_enter_id = 1
  dwt_exit_id = 2
  lts_prescaler = 1

  # Whether it is expected that the target generates packets that do not adhere to the ITM standard.
  # For debugging purposes.
  expect_malformed = true
#+end_src

# TODO document cortex-m-rtic-trace usage

** Discussion
:PROPERTIES:
:CUSTOM_ID: discussion
:END:
*** What project does ~itm~ belong to?
:PROPERTIES:
:CUSTOM_ID: disc:itm-embedded-wg
:END:
# TODO discuss on where the final itm actually belongs. Link to the RFC discussion.
*** Tracing overhead with RTIC Scope
:PROPERTIES:
:CUSTOM_ID: disc:perf
:END:
[[parencite:&arm-cortex-learn 24]] states:
#+begin_quote
Except for the power that is consumed by the system trace components,
trace is almost entirely non-invasive. This means that performing trace
generation and collection does not influence the wider system.
#+end_quote

The target-side code of RTIC Scope itself has a negligible performance impact during execution:
- the ITM/DWT/TPIU units need only be configured once in =#[init]= or during some other preparatory stage; and
- when software tasks are traced, a =u8= variable write must be done when entering and exiting the task.

The performance of the host-side ~cargo-rtic-scope~ and ~rtic-scope-frontend-dummy~ have not been measured.

# TODO DWT unit consumption, 2x u32-aligned .data usage
# TODO add a listing of the watch variable structs to detail alignment.
*** Future work
# Link to all(?) issues

# TODO deprecating cortex-m-rtic-trace: push upstream to RTIC, probe-rs
# TODO cargo-embed functionality, RTICScope.toml
# TODO queries from frontend
# TODO replace serde with protobuf
# TODO HIL testing?
# TODO replace bash scripts with xtask testing
# TODO Cargo warning/errors not propagated when building application
# TODO Cargo-flash hints?

# TODO add a link to the issue tracker, or should we list all issues that are open when v0.3.0 is tagged?
**** Local timestamp prescaler configuration
:PROPERTIES:
:CUSTOM_ID: fut:swoscaler
:END:
# TODO integer division
**** Trace stream ID configuration
:PROPERTIES:
:CUSTOM_ID: fut:TraceBusID
:END:
# TODO 0 may not be a valid value, and tracebusid should be set before ITMENA
**** [[ACRshort:DWT]] comparator configuration
:PROPERTIES:
:CUSTOM_ID: fut:dwtcomps
:END:
# TODO move positional arguments to the struct instead. ensure that the two comparators are not the same one.
**** Optimizing [[ACRshort:DWT]] comparator utilization
:PROPERTIES:
:CUSTOM_ID: fut:opt-dwt-units
:END:
It would then be logical to store both =u8= variables on the same 32-bit address base: the first at offset 0, the other at offset 1.

# TODO elaborate

** Conclusion
** Glossary & Bibliography                                          :ignore:
[[printglossaries:]]
[[printbibliography:]]
** Appendices                                                       :ignore:
#+begin_export latex
\appendix
\addappheadtotoc
#+end_export
*** TODO Application to a complex control system
:PROPERTIES:
:CUSTOM_ID: control-application
:END:
 # The results of the R7014E-alike course



* Footnotes
[fn:recovery-build] A positive side-effect of this step is that the RTIC Scope user does not have to manually call =cargo build= before =cargo rtic-scope trace=.

[fn:2] Additional tasks aside from regulation could for example include handling firmware updates over the air and switching mode of operation on a button press.
[fn:1] The program that executes on the embedded system when initialization has concluded. In some contexts also referred to as the "main loop".

[fn:cargo-cdylibs] See
https://docs.rs/cargo/0.52.0/cargo/core/compiler/struct.Compilation.html#structfield.cdylibs.

[fn:cdylib] A cdylib crate is a crate that specifies =crate_type = ["cdylib"]=.
Upon building the crate a dynamic library (a shared object file) that targets the stable C ABI is generated.
Additionally, it is trivial to find the file location of cdylibs with cargo[fn:cargo-cdylibs].
This is not the case with dylibs that instead target the unstable Rust ABI.
The only way to generate a shared object file is by building a dylib or a cdylib.

[fn:dwt-running-bit] Alternatively, one bit in the =DataTraceValue= payload can denote whether a task was entered or exited.

[fn:cargo] See https://crates.io/crates/cargo.

[fn:rtic-syntax] See https://crates.io/crates/rtic-syntax.

[fn:decoder] Based upon the existing works of ~itm-tools~[fn:itm-tools].

[fn:memory-lanes] https://github.com/rtic-rs/rfcs/issues/31 discusses the RTIC-abstraction of RTT and similar peripherals to "memory lanes".

[fn:itm-tools] See https://github.com/japaric/itm-tools.

[fn:cli] Command-line interface.

[fn:dwt-n] $n$ emphasized for reasons of readability and typesetting.
