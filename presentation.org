#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:t f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: RTIC Scope â€” Real-Time Tracing Support for the RTIC RTOS Framework
#+subtitle: Hardware-assisted logging for minimized observer effect
#+author: Viktor Sonesten
#+email: vikson-6@student.ltu.se
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.0.50 (Org mode 9.5.1)
#+cite_export:

#+latex_class: article
#+latex_class_options:
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today

#+startup: beamer
#+latex_class: beamer
#+latex_class_options: []
#+BEAMER_THEME: Berkeley

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   >=latex,
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

* Introduction
** What do I do?
- I work at Grepit AB on embedded systems. Hired in 2018, full-time since November.
- We use embedded Rust and RTIC on Cortex-M MCUs.
- Grepit has helped with the bankrolling of this project.
- Chief interests are safety-critical systems and embedded control systems.

** The problem
How do we verify the operation of our embedded systems?

We cannot halt the processor for inspection, especially for control system applications.

"printf-debugging" is applied: payloads are written such that the system state over time is logged.

** The problem (cont.)
How do we log RTIC tasks without affecting the program?

Observer effect says we cannot remove the overhead, but how can we minimize the effect?

* Live debugging methods
** Possible solutions?
*** Semi-hosting                                              :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Very slow, esp. formatting.

*** RTT                                                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Possible I/O block.

*** Defmt                                                     :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Best approach, but can we do better?

** /The/ solution: "tracing"
Hardware-assisted logging via ARMv7-M debug peripherals:
- Available on e.g. Cortex-M4 and Cortex-M7
- No effect on wider system
- Subsystem that monitors:
  - enters/exits/returns of hardware interrupts;
  - configurable monitoring of arbitrary memory accesses;
  - arbitrary payload registers ("instrumentation data");
  - program counter values; etc.

On subsystem trigger, a trace packet is generated and emitted on the /Serial Wire Out/ (SWO) pin that speaks UART.
Can be decoded with your standard FT232 variant (UART-to-USB circuit).

* The ARMv7-M debug peripherals
** Debug peripheral functions
*** The /Data Watchpoint and Trace/ (DWT) unit
Monitors hardware events:
- interrupt enters/exits/returns;
- memory accesses;
- program counter values; etc.
*** The /Intrumentation Macrocell/ (ITM) unit
Muxes DWT packets with its own:
- instrumentation data when written;
- timestamps (absolute and relative); and
forwards these to the TPIU.
*** The /Trace Port Interface Unit/ (TPIU)
Serializes ITM packets and emits them on the SWO pin, by help of a reference clock.
# Use a frame here to show how a signal can be read on a host system.
** Peripheral relationship
#+begin_export latex
\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance = 1cm, auto, scale = 0.6]
  \node[block] (clock) {timestamp clock};
  \node[block, below=0.5cm of clock] (itm) {ITM \\ (timestamps, \\ multiplexing, etc.)};
  \node[block, left=of itm] (dwt) {DWT \\ (hardware events)};
  \node[block, right=of itm] (tpiu) {TPIU \\ (serialization)};
  \node[block, above=0.5cm of tpiu] (prescaler) {prescaler: $/n$};
  \node[block, above=0.5cm of prescaler] (freq) {reference \\ clock $\left[\text{Hz}\right]$};
  \node[below=of tpiu.south] (swo) {SWO};
  \path[->]
  (dwt) edge (itm)
  (clock) edge (itm)
  (itm) edge (tpiu)
  (freq) edge (prescaler)
  (prescaler) edge (tpiu)
  (tpiu) edge (swo);

  %% box
  \node[above=0.5cm of clock] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}};
  \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=($(dwt.west)+(-0.3,0)$), \p2=($(target.north)+(0.0,0.3)$), \p3=($(tpiu.south east)+(0.3,-0.3)$), \p4=($(itm.south)+(0,-0.3)$) in (\x1, \y2) rectangle (\x3, \y4);

\end{tikzpicture}
\caption{\label{fig:debug-relations}Downstream relationship between ARMv-7M debug peripherals used for tracing.}
\end{figure}
#+end_export



* Theory
** Tracing RTIC tasks
- Hardware tasks :: bound to interrupts: traced "for free" when tracing enabled.
- Software tasks :: Bound non-exclusively to an interrupt via task dispatcher, write /Unique Task ID/ (UTID) to monitored memory address via /watch variables/.

** The ITM packet protocol

*** Execption trace packets

*** Data trace value packets
# DWT comparators

*** Timestamp packets
Two types:
- Global timestamps :: image of reference clock register value.
- Local timestamps :: relative/delta: denotes time since last local timestamp.

* Implementation
Five crates created. We'll cover them in a down-stream fashion.

** Crates
- =cortex_m_rtic_trace= :: Target-side crate for debug peripheral configuration (via =configure= function) and software task tracing (via =trace= macro).
- =cargo-rtic-scope= :: Host-side =cargo= subcommand daemon/backend that recovers trace metadata and records emitted trace packets. Enables portmortem replays.
- =itm= :: A library crate for trace stream decoding into Rust structures.
- =rtc-scope-frontend-dummy= :: Reference implementation of a RTIC Scope frontend. Simply prints the trace stream to =stdout=.
- =rtic-scope-api= :: JSON-API used for communication between the RTIC Scope backend to frontends.
** Debug peripheral configuration via ~cortex_m_rtic_trace~
#+begin_src rust
  // configure tracing
  cortex_m_rtic_trace::configure(
      &mut ctx.core.DCB,
      &mut ctx.core.TPIU,
      &mut ctx.core.DWT,
      &mut ctx.core.ITM,
      1, // task enter DWT comparator ID
      2, // task exit DWT comparator ID
      &TraceConfiguration {
          delta_timestamps: LocalTimestampOptions::Enabled, // enabled with a bypassed (= 1) prescaler
          absolute_timestamps: GlobalTimestampOptions::Disabled, // disable absolute timestamps
          timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
          tpiu_freq: trace_clk.freq().0, // Hz
          tpiu_baud: 1_000_000,          // B/s
          protocol: TraceProtocol::AsyncSWONRZ,
      },
  )
  .unwrap();
#+end_src
** Tracing software task via ~trace~ macro
** Decoding the trace stream
TLV: very simple to pattern match.
** Resolving raw trace data back to RTIC tasks (recovery)

* Example application
** Example: Tracing the ATSAME
** Example: Plotting a run-time graph
* Future work
