#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:t f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: RTIC Scope — Real-Time Tracing Support for the RTIC RTOS Framework
#+subtitle: Hardware-assisted logging for minimized observer effect
#+author: Viktor Sonesten
#+email: vikson-6@student.ltu.se
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.0.50 (Org mode 9.5.1)
#+cite_export:

#+latex_class: article
#+latex_class_options:
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today

#+startup: beamer
#+latex_class: beamer
#+latex_class_options: [aspectratio=169,12pt]
#+BEAMER_THEME: Berkeley

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   >=latex,
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

* Introduction
** What do I do?
*** Summary                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
- I work at Grepit AB on embedded systems. Hired in 2018, full-time since November.
- We use embedded Rust and RTIC on Cortex-M MCUs.
- Funded part of this thesis, for later application on products.
- My chief interests are safety-critical systems and embedded control systems.
*** Grepit logo                                                       :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
[[./svgs/grepit.png]]



** The problem
How are embedded systems verified while they are running?

*** Halt and inspect?                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:BEAMER_act: <2->
:END:
Disrupts operation (esp. control system applications).

*** Continuously emit internal system state?                        :B_block:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_act: <3>
:END:
- Known as /logging/ or /tracing/.
- Emitted data is collected host-side and inspected.
- Does not disrupt operation, but overhead is added.

** The exact problem
How do we log the run-time status of RTIC tasks without affecting them?

- We want to acquire information on when tasks enter, exit, and are preempted.

*** Requests: what do we want?                                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_act: <2->
:END:
- R1 :: Minimized observer effect: no overhead, please.

- R2 :: Timestamped task state changes.

- R3 :: Easy application: no end-user overhead, please.

** Contemporary logging methods
What methods can we apply without re-inventing the wheel?

*** Semihosting?                                         :B_alertblock:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.48
:BEAMER_env: alertblock
:BEAMER_act: <2->
:END:
- *Halts the CPU* to give temporary control to the debug agent.
- *R1 unfulfilled.*

*** Regular UART?                                        :B_alertblock:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.48
:BEAMER_env: alertblock
:BEAMER_act: <3->
:END:
- Potentially non-blocking, real-time.
- Timestamps via an asynchronous clock.
- Accurate timestamps?
- *R2, R3 fulfilled?*

* Theory
** The solution: exploit hardware features
Hardware-assisted logging via ARMv7-M debug peripherals:
- Available on e.g. Cortex-M4 and Cortex-M7
- No effect on wider system
- Subsystem that monitors:
  - enters/exits/returns of hardware interrupts;
  - configurable monitoring of arbitrary memory accesses;
  - arbitrary payload registers (/instrumentation data/); etc.

*** On subsystem trigger                                            :B_block:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_act: <2->
:END:
Asynchronous emission of a /trace packet/ unto the /Serial Wire Out/ (SWO) pin that speaks UART.

** Debug peripheral functions
*** The /Data Watchpoint and Trace/ (DWT) unit                :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.31
:BEAMER_env: block
:END:
Monitors hardware events:
- interrupt (task) enters, exits, and returns;
- memory accesses; etc.
*** The /Intrumentation Macrocell/ (ITM) unit                 :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.31
:BEAMER_env: block
:BEAMER_act: <2->
:END:
Muxes DWT packets with its own:
- instrumentation packets;
- timestamps (absolute, relative); and
forwards these to the TPIU.
*** The /Trace Port Interface Unit/ (TPIU)                    :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.31
:BEAMER_env: block
:BEAMER_act: <3->
:END:
Emits packets unto the SWO pin, by help of a reference clock.

** Debug peripheral relationship
#+begin_export latex
\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance = 1cm, auto, scale = 0.4]
  \node[block] (clock) {timestamp clock};
  \node[block, below=0.5cm of clock] (itm) {ITM \\ (timestamps, \\ multiplexing, etc.)};
  \node[block, left=of itm] (dwt) {DWT \\ (hardware events)};
  \node[block, right=of itm] (tpiu) {TPIU \\ (serialization)};
  \node[block, above=0.5cm of tpiu] (prescaler) {prescaler: $/n$};
  \node[block, above=0.5cm of prescaler] (freq) {reference \\ clock $\left[\text{Hz}\right]$};
  \node[below=of tpiu.south] (swo) {SWO};
  \path[->]
  (dwt) edge (itm)
  (clock) edge (itm)
  (itm) edge (tpiu)
  (freq) edge (prescaler)
  (prescaler) edge (tpiu)
  (tpiu) edge (swo);
\end{tikzpicture}
\end{figure}
#+end_export

** The ITM packet protocol
Packets of interest:

*** Exception trace packets                                   :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.48
:BEAMER_env: block
:END:
Numerical value of interrupt, and the event type: enter, exit, or return.
*** Data trace value packets                                  :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.48
:BEAMER_env: block
:END:
The written data, and what DWT /hardware comparator/ saw the write.

*** Timestamp packets                                               :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Emitted after non-timestamp packets.
Two types:
- Global timestamps :: image of reference clock register value.
- Local timestamps :: relative/delta: denotes time since last local timestamp.

** Tracing RTIC tasks
- Hardware tasks :: bound to interrupts: traced for free when tracing enabled.
- Software tasks :: Bound non-exclusively to an interrupt via task dispatchers, write a /Unique Task ID/ (UTID) to monitored memory address via /watch variables/.

*** Requests fulfilled?                                             :B_block:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_act: <2->
:END:
- R1 :: "No effect on wider system" — ARM.
- R2 :: Handled by the ITM.
- R3 :: Trace packets contain no RTIC metadata, how much work can we automate?

* Implementation
Five crates created. We'll cover them in a down-stream fashion.

** Crates
- =cortex_m_rtic_trace= :: Target-side crate for debug peripheral configuration (via =configure= function) and software task tracing (via =trace= macro).
- =cargo-rtic-scope= :: Host-side =cargo= subcommand daemon/backend that recovers trace metadata and records emitted trace packets. Enables portmortem replays.
- =itm= :: A library crate for trace stream decoding into Rust structures.
- =rtc-scope-frontend-dummy= :: Reference implementation of a RTIC Scope frontend. Simply prints the trace stream to =stdout=.
- =rtic-scope-api= :: JSON-API used for communication between the RTIC Scope backend to frontends.
** Debug peripheral configuration via ~cortex_m_rtic_trace~
#+begin_src rust
  // configure tracing
  cortex_m_rtic_trace::configure(
      &mut ctx.core.DCB,
      &mut ctx.core.TPIU,
      &mut ctx.core.DWT,
      &mut ctx.core.ITM,
      1, // task enter DWT comparator ID
      2, // task exit DWT comparator ID
      &TraceConfiguration {
          delta_timestamps: LocalTimestampOptions::Enabled, // enabled with a bypassed (= 1) prescaler
          absolute_timestamps: GlobalTimestampOptions::Disabled, // disable absolute timestamps
          timestamp_clk_src: TimestampClkSrc::AsyncTPIU,
          tpiu_freq: trace_clk.freq().0, // Hz
          tpiu_baud: 1_000_000,          // B/s
          protocol: TraceProtocol::AsyncSWONRZ,
      },
  )
  .unwrap();
#+end_src
** Tracing software task via ~trace~ macro
** Decoding the trace stream
TLV: very simple to pattern match.
** Resolving raw trace data back to RTIC tasks (recovery)

* Example application
** Example: Tracing the ATSAME
** Example: Plotting a run-time graph
* Future work
** Blah
* Questions?
** Questions?
Where is all the work?
- RTIC Scope at [[https://github.com/rtic-scope]]. Contributions welcome!
- Related thesis (and this presentation) at [[https://github.com/tmplt/masters-thesis]].
