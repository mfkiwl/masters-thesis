#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:t f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: RTIC Scope â€” Real-Time Tracing Support for the RTIC RTOS Framework
#+author: Viktor Sonesten
#+email: vikson-6@student.ltu.se
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.0.50 (Org mode 9.5.1)
#+cite_export:

#+latex_class: article
#+latex_class_options:
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today

#+startup: beamer
#+latex_class: beamer
#+latex_class_options: [bigger]

#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{automata, positioning, arrows, shapes, calc}
#+latex_header: \tikzset{
#+latex_header:   block/.style = {draw, rectangle, minimum height=1cm, minimum width=2cm},
#+latex_header:   ->, % make edges directed
#+latex_header:   >=latex,
#+latex_header:   every text node part/.style={align=center}, % allow multiline node descriptions
#+latex_header: }

* Introduction
** What do I do?
- I work at Grepit AB on embedded systems. Hired in 2018, full-time since November.
- We use embedded Rust and RTIC on Cortex-M MCUs.
- Grepit has helped with the bankrolling of this project.
- Chief interests are safety-critical systems and embedded control systems.

** The problem
How do we verify the operation of our embedded systems?

We cannot halt the processor for inspection, especially for control system applications.

"printf-debugging" is applied: payloads are written such that the system state over time is logged.

** The problem (cont.)
How do we log RTIC tasks without affecting the program?

Observer effect says we cannot remove the overhead, but how can we minimize the effect?

* Live debugging methods
** Possible solutions?
*** Semi-hosting                                              :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Very slow, esp. formatting.

*** RTT                                                       :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Possible I/O block.

*** Defmt                                                     :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:BEAMER_env: block
:END:
Best approach, but can we do better?

** /The/ solution: "tracing"
Hardware-assisted logging via ARMv7-M debug peripherals:
- Available on e.g. Cortex-M4 and Cortex-M7
- No effect on wider system
- Subsystem that monitors:
  - enters/exits/returns of hardware interrupts;
  - configurable monitoring of arbitrary memory accesses;
  - arbitrary payload registers ("instrumentation data");
  - program counter values; etc.

On subsystem trigger, a trace packet is generated and emitted on the /Serial Wire Out/ (SWO) pin that speaks UART.
Can be decoded with your standard FT232 variant (UART-to-USB circuit).

* The ARMv7-M debug peripherals
** Debug peripheral functions
*** The /Data Watchpoint and Trace/ (DWT) unit
Monitors hardware events:
- interrupt enters/exits/returns;
- memory accesses;
- program counter values; etc.
*** The /Intrumentation Macrocell/ (ITM) unit
Muxes DWT packets with its own:
- instrumentation data when written;
- timestamps (absolute and relative); and
forwards these to the TPIU.
*** The /Trace Port Interface Unit/ (TPIU)
Serializes ITM packets and emits them on the SWO pin, by help of a reference clock.
# Use a frame here to show how a signal can be read on a host system.
** Peripheral relationship
#+begin_export latex
\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance = 1cm, auto, scale = 0.6]
  \node[block] (clock) {timestamp clock};
  \node[block, below=0.5cm of clock] (itm) {ITM \\ (timestamps, \\ multiplexing, etc.)};
  \node[block, left=of itm] (dwt) {DWT \\ (hardware events)};
  \node[block, right=of itm] (tpiu) {TPIU \\ (serialization)};
  \node[block, above=0.5cm of tpiu] (prescaler) {prescaler: $/n$};
  \node[block, above=0.5cm of prescaler] (freq) {reference \\ clock $\left[\text{Hz}\right]$};
  \node[below=of tpiu.south] (swo) {SWO};
  \path[->]
  (dwt) edge (itm)
  (clock) edge (itm)
  (itm) edge (tpiu)
  (freq) edge (prescaler)
  (prescaler) edge (tpiu)
  (tpiu) edge (swo);

  %% box
  \node[above=0.5cm of clock] (target) {target configured with \\ \texttt{cortex-m-rtic-trace}};
  \draw[dotted,fill=yellow,fill opacity=0.2] let \p1=($(dwt.west)+(-0.3,0)$), \p2=($(target.north)+(0.0,0.3)$), \p3=($(tpiu.south east)+(0.3,-0.3)$), \p4=($(itm.south)+(0,-0.3)$) in (\x1, \y2) rectangle (\x3, \y4);

\end{tikzpicture}
\caption{\label{fig:debug-relations}Downstream relationship between ARMv-7M debug peripherals used for tracing.}
\end{figure}
#+end_export



* RTIC Scope: debug peripheral configuration and host-side trace collection

** ~cortex_m_rtic_trace~

** ~cargo rtic-scope~
*** Information recovery
*** The ~itm~ decoding library
*** Utilizing the recovered information

** RTIC Scope frontends

*** The ~dummy~ reference implementation

*** Example: Plotting a run-time graph

* Future work
